<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<meta name="progressive" content="false" />
<meta name="allow-skip" content="false" />

<title>Tutorial</title>


<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



</head>

<body>



<div class="pageContent band">
<div class="bandContent page">

<div class="topics">

<div id="section-overview" class="section level2" data-progressive="TRUE">
<h2>Overview</h2>
<p>The purpose of this document is to introduce you to some basic mathematical ideas in a strongly pragmatic environment and reinforce those ideas by examples in both R and python.</p>
<p>The focus of this document will be on <em>practical applications</em>.</p>
</div>
<div id="section-number-systems" class="section level2">
<h2>Number Systems</h2>
<p>At a certain point in your mathematical career you will need to expand your ideas about numbers. You will undoubtedly already have been exposed to some of these ideas:</p>
<ul>
<li><strong>Natural Numbers:</strong> <span class="math inline">\(\left\{1,2,3, \cdots\right\}\)</span> (some people include 0 in this set)</li>
<li><strong>Integers:</strong> <span class="math inline">\(\left\{\cdots,-3,-2,-1,0,1,2,3,\cdots\right\}\)</span> (symbolized as <span class="math inline">\(\mathbb{Z}\)</span>)</li>
<li><strong>Rational Numbers:</strong> <span class="math inline">\(\left\{\frac{a}{b} | a,b \in \mathbb{Z} \right\}\)</span></li>
<li><strong>Real Numbers:</strong> : Numbers that naturally correspond to <em>lengths</em>. Typically represented using decimal notation, but with the understanding that the decimal expression of a number (consider <span class="math inline">\(\pi\)</span>) may be infinite and non-repeating.</li>
</ul>
<p>Mathematical notation uses <span class="math inline">\(\in\)</span> to represent the set to which a variable belongs. FOr example, “<span class="math inline">\(n \in \mathbb{N}\)</span>” means that <span class="math inline">\(n\)</span> is a natural number. Whereas <span class="math inline">\(x \in \mathbb{Q}\)</span> means that <span class="math inline">\(x\)</span> is a rational number.</p>
<p>An <strong>operation</strong> takes two elements of one types and produces a third element of the same type. For example, <strong>addition</strong> is an operation on the real numbers. Consider the real numbers <span class="math inline">\(2.5\)</span> and <span class="math inline">\(3.1\)</span>. Adding the two together produces the real number 5.6:</p>
<p><span class="math display">\[
2.5 + 3.1 = 5.6
\]</span></p>
<p>We can define a <strong>subtraction</strong> operation on the real numbers, but on the natural numbers such an operation is only <strong>partially defined</strong>. For example, there <strong>are no natural numbers</strong> that correspond to <span class="math inline">\(2-3\)</span>. There <strong>are</strong> integers… but that is a different set of numbers.</p>
<p>The number systems I have described above have a natural “<strong>inclusion</strong>” which puts one inside of the next in a natural way:</p>
<p><span class="math display">\[
\mathbb{N} \subset \mathbb{Z} \subset \mathbb{Q} \subset \mathbb{R}
\]</span></p>
<p>The inclusions are proper– which means as you move to the right, there are <strong>new</strong> elements that aren’t found previously. For example, the real numbers that are <strong>Not rational</strong> are called the <strong>irrational</strong> numbers.</p>
<p>It is a fun fact that <span class="math inline">\(\sqrt{2}\)</span> is irrational.</p>
</div>
<div id="section-number-systems-on-a-computer" class="section level2">
<h2>Number systems on a computer</h2>
<p>Mathematical number systems are, typically, infinite. That doesn’t work so well on a computer (they are notoriously finite). Review bits, bytes, (look up name), but the key idea is that on a computer number systems are finite sets. For example, a signed 8 bit integer can takes values from -128 to 127 and floating point numbers, although <strong>technically</strong> all floating point values are rational numbers they are more often thought of as <strong>real numbers</strong> (<span class="math inline">\(\mathbb{R}\)</span>).</p>
<p>R has a fairly limited number of numeric types. Basically integers and floating points. The R variable <code>.machine</code> contains information about machine specific implementations of numeric formats. For example <code>.machine$integer.max</code> will reveal the largest integer to be <code>2147483647</code> (we can figure out how many bits this is using by taking the log base 2): <code>log(base=2,.machine$integer.max)</code>. On the machine that I’m using to produce this document that value is 31… so we know that the integers are 32-bit integers. (we can use 31 bits for the positive values and we need the other bit to distinguish between positive and negative values. So the range of values is <span class="math inline">\(2^31-1\)</span> to <span class="math inline">\(2^31\)</span> [recall that we need one of those 320bit configurations to represent 0]).</p>
<p>The “float” (really, “double”) uses 8 bytes or 64 bits. The full range of what can be represented is complicated (refer to bits, bytes, etc). Recall that there are hidden “gotchas”. In particular, <code>0.1*3</code> is NOT equal to <code>0.3</code> in R. This is because as a binary decimaal, 0.1 is infinitely repeated (similarly as to how 1/3 = <span class="math inline">\(0.111\cdots\)</span> in normal decimal notation). <span class="math inline">\(3*0.1\)</span> <strong>rounds</strong> one way, while <span class="math inline">\(0.3\)</span>, which is calculated as 3/10 rounds differently.</p>
<p>Python 2.x supports</p>
<ul>
<li>int</li>
<li>long</li>
<li>float</li>
</ul>
<p>Python 3.x only has</p>
<ul>
<li>int</li>
<li>float</li>
</ul>
<p>But <code>int</code> has infinite precision in Python. This means that unlike the other situation that I have outlined there is no maximum representable value (in principal)… the computer will use as much memory as it needs (hence there is <em>sort of</em> an upper limit on the maximum integer that can be represented– but it will depend upon the amount of RAM in the system).</p>
</div>
<div id="section-more-abstractions" class="section level2">
<h2>More abstractions</h2>
<p>It’s not a large step to go from <code>number</code> as a mathematical object to a <code>list of numbers</code> as a mathematical object. Consider “short” lists comprised of <strong>two</strong> numbers. We can easily introduce <code>+</code> by <strong>component-wise</strong> addition:</p>
<p><span class="math display">\[(a,b)+(c,d) = (a+c,b+d)\]</span></p>
<p>For example,</p>
<p><span class="math display">\[(2,-1) + (3.5,0.2) = (2+3.5,-1+0.2) = (5.5,-0.8)\]</span> Other additions are possible… such as:</p>
<p><span class="math display">\[(a,b)+(c,d) = (a+c,bd)\]</span> Does that seem like a strange operation? What if I wrote it this way:</p>
<p><span class="math display">\[
\frac{a}{b} + \frac{c}{d} = \frac{a+c}{bd}
\]</span> There are many more ways that we could define an addition on a pair of numbers–even more so if we consider triplets, or quadruplets, etcs. What we want are some very specific <strong>properties</strong> to be followed. We will develop those properties in due order, but first let’s pull back to the broader picture.</p>
</div>
<div id="section-vectors" class="section level2">
<h2>Vectors</h2>
<p>The first mathematical idea that we are going need is <strong>the vector</strong>. This is the purview of <strong>linear algebra</strong> and we are not going to have time to learn all of it. The **first* key idea is as follows:</p>
<p><span class="math display">\[
\textrm{Key Idea 1: A vector is an array}
\]</span></p>
<p>This simple statement does a <em>terrible</em> disservice to the underlying mathematics, but it really captures the essence of what we, mostly, will care about for data science. In normal terms, a vector is a list of numbers. Let’s see an example:</p>
<div id="section-vector-example-in-r" class="section level3">
<h3>Vector example in R</h3>
<p>In the language of R, what almost every other language calls an array is called a <strong>vector</strong>. We can explicitly build one using the R-function <code>c()</code>, or we can use the output of a function such as <code>seq()</code> (which builds sequences of values), or we can use an expression such as <code>3:10</code>:</p>
<pre><code>## [1] 10 20 30 40 50</code></pre>
<pre><code>## [1] 10</code></pre>
<pre><code>## [1] 20</code></pre>
<pre><code>## [1] 10 20</code></pre>
<pre><code>## [1] 10 10 40</code></pre>
<pre><code>## [1] 20 30</code></pre>
</div>
<div id="section-vector-example-in-python" class="section level3">
<h3>Vector example in Python</h3>
<p>It’s important to notice that in both languages we use <code>var[i]</code> to get at an individual entry, but R is 1-based and Python is 0-based. So the <strong>first</strong> element in an array is <code>var[1]</code> in R and it is <code>var[0]</code> in Python<a href="#section-fn1" class="footnote-ref" id="section-fnref1"><sup>1</sup></a>.</p>
<pre><code>## [10, 20, 30, 40, 50]</code></pre>
<pre><code>## 10</code></pre>
<pre><code>## 20</code></pre>
<pre><code>## [20, 30]</code></pre>
<pre><code>## [20, 20, 50]</code></pre>
<p><span class="math display">\[
\textrm{Key Idea 2: A vector indicates a direction}
\]</span></p>
<p>More than that– it indicates a direction <strong>and</strong> a magnitude (amount). From this point of view with start by thinking of a list of numbers as a set of coordinates indicating a position in some space and draw an arrow from the origin to the point. We usually draw a circle at the <strong>base</strong> and an arrow head at the <strong>head</strong> of the vector.</p>
<p>For example, the list <span class="math inline">\((2,3)\)</span> has the following graphic representation:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-3-1.png" width="624" /></p>
<p>Now if we view the <strong>meaning</strong> of that arrow as a <strong>displacement</strong> then the natural idea of a direction (coupled with a distance) arises. This distinction between vector as <strong>position</strong> and vector as <strong>direction</strong> is important AND it is something that you have seen before with simple numbers. Let me give you an example:</p>
<p>10 degrees Celsius is 50 degress Fahrenheit (position)</p>
<p><strong>BUT</strong> if I tell you that the temperature <strong>changed</strong> by 10 degrees Celsius, then by how many degrees did the temperature change in Fahrenheit? (displacement)? Answer: 18 degrees Fahrenheit. Not convinced?</p>
<p>10 degrees Celsius is 50 degrees Fahrenheit 0 degrees Celsius is 32 degrees Fahrenheit ——————————————- (10-0) degress Change in C is (50-32) degree change in F</p>
<p>The conversion formula has a graph that is a straigh line <span class="math display">\[
\textrm{F} = \frac{9}{5}\textrm{C} + 32
\]</span></p>
<p>The change in <span class="math inline">\(\textrm{F}\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
\textrm{F}_1 - \textrm{F}_2 &amp;= \biggl(\frac{9}{5}\textrm{C}_1 + 32\biggr) - \biggl(\frac{9}{5}\textrm{C}_2 + 32\biggr)\\
&amp;= \frac{9}{5} \biggl(\textrm{C}_1-\textrm{C}_2\biggr)-\biggl(32-32\biggr)\\
&amp;= \frac{9}{5} \biggl(\textrm{C}_1-\textrm{C}_2\biggr)\\
\textrm{Change in F}&amp;= \frac{9}{5} \biggl(\textrm{Change in C}\biggr)
\end{aligned}
\]</span></p>
<p>Notice that a 10 degrees change in <span class="math inline">\(\textrm{C}\)</span> becomes <span class="math inline">\(\frac{9}{5}10= 18\)</span> change in <span class="math inline">\(\textrm{F}\)</span>.</p>
<p>So the same number 10 (here we are thinking of it as a vector of length 1) can be a <strong>position</strong> (10 degrees <span class="math inline">\(\textrm{C}\)</span>) <strong>or</strong> a displacment (<em>change</em> by 10 degress <span class="math inline">\(\textrm{C}\)</span>). And the conversion rule that we need to use when we change from Celsius to Fahrenheit actually changes– a fact that underscores the differences between the two. Most of the time in this class we can just think of a vector as a list– a position in data-space… <strong>however</strong> we will also be looking at techniques similar to finding lines of best fit that involve us to “move”, step-by-step, through “parameter space”. These “steps” will be vectors thought of as displacements… so I want to talk about that just a little bit more.</p>
<p>The number 10 (<em>as a position</em>) is, in a sense absolute. The number 10 (<em>as a displacment</em>) only becomes a position when a starting point is specified. But “displacement” math still makes sense without knowing this:</p>
<ul>
<li>A displacment of 10 units to the right (+10)</li>
<li>followed by a displace of 4 units to the left (-4)</li>
</ul>
<p>Is a displacement of 10-4 = 6 units to the right.</p>
<p>Similarly a displacement of <span class="math inline">\((1,2)\)</span> followed by a displacement of <span class="math inline">\((-3,4)\)</span> is <span class="math inline">\((1,2) + (-3,4) = (1-3,2+4) = (-2,6)\)</span>– namely a displacement of -2 units along <span class="math inline">\(x\)</span> followed by a displacement of 6 units along <span class="math inline">\(y\)</span>.</p>
<p>All of this is probably sounding pretty pedantic, but the distinction is important. A displacement of <span class="math inline">\((1,2)\)</span> <strong>at</strong> <span class="math inline">\((-3,4)\)</span> produces a news position of <span class="math inline">\((-2,6)\)</span>. Again– <span class="math inline">\((-2,6)\)</span> can be a position <strong>or</strong> a displacement– it all depends upon the context.</p>
</div>
<div id="section-why-vectors" class="section level3">
<h3>Why vectors?</h3>
<p>If a vector is just an array… then why do we care about the mathematical idea of vectors?</p>
<p>This is where things get interesting. In mathematics your first interpretation of a vector is as a list of numbers… but it comes equipped with <strong>vector operations</strong>. These are things that take <strong>two</strong> vectors and produced a <strong>third</strong>. For example: Addition:</p>
<pre><code>## [1]  9 22 25 47</code></pre>
<pre><code>## [10, 20, 30, 40, -1, 2, -5, 7]</code></pre>
<p><strong>DANGER</strong>: That did something else. That <strong>concatenated</strong> the two. If we want the arrays to behave like vectors in python we need to use the package <code>numpy</code>:</p>
<pre><code>## array([ 9, 22, 25, 47])</code></pre>
<p>So what makes something a vector anyway?</p>
</div>
<div id="section-the-mathematical-details" class="section level3">
<h3>The mathematical details</h3>
<p>In the mathematical sense, a vector is more than just a list of numbers. There must be a way to <strong>add</strong> the vectors together <strong>and</strong> a way to <strong>scale</strong> a vector. The <strong>scaling</strong> is associated to a set of numbers called the <strong>scalars</strong>.</p>
<p>In this class we are typically dealing with <strong>real numbers</strong> so the <strong>vector</strong> is a list of real number and the <strong>scalars</strong> are also real numbers. Let’s see a simple example:</p>
<p><span class="math display">\[
\begin{aligned}
A&amp;=(2,3)\\
B&amp;=(3,-1)\\
A+B &amp;= (5,2)\\
-2B &amp;= (-6,2)
\end{aligned}
\]</span></p>
<p>In the example above we added the vectors <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> and we <strong>scaled</strong> the vector <span class="math inline">\(B\)</span> by the scaling factor <span class="math inline">\(-2\)</span>.</p>
<p>Mathematics is all about generalization. So the most abstract definition of <strong>vector</strong> can be quite hard to understand. When we use <strong>real numbers</strong> we get some properties “<em>for free</em>”. For example, in the real numbers, <span class="math inline">\(\mathbb{R}\)</span>, there is a special number called <span class="math inline">\(0\)</span> with the unique property that it leaves values unchanged <strong>Under addition</strong>. For example, <span class="math inline">\(3.5 + 0 = 3.5\)</span>. This number is called the <strong>additive identity</strong>. For the real numbers there is a <strong>multiplicative identity</strong> called <span class="math inline">\(1\)</span>. For example, <span class="math inline">\(3.5*1 = 3.5\)</span>.</p>
<p>On the other hand, in the natural numbers, <span class="math inline">\(\mathbb{N}\)</span>, (if you are in the “no 0” camp) there is no additive identity.</p>
<p>Another thing that comes for free with the real numbers is an <strong>additive inverse</strong>. This is the unique number that can be added to another to get to the additive identity. For example, <span class="math inline">\(2+(-2) = 0\)</span>. The real number <span class="math inline">\(-2\)</span> is the only real number you can <strong>add</strong> to <span class="math inline">\(2\)</span> to get produce a <span class="math inline">\(0\)</span>. Similarly, <span class="math inline">\(2\)</span> is the only real number that you can add to <span class="math inline">\(-2\)</span> to produce a <span class="math inline">\(0\)</span>.</p>
<p>You need the following details:</p>
<ol style="list-style-type: decimal">
<li>An ability to add</li>
<li>An ability to <strong>scale</strong> (we call this <strong>scalar multiplication</strong>)</li>
</ol>
<p>We will require a few more things too:</p>
<ol style="list-style-type: decimal">
<li>An additive identity typically called 0, but do not be fooled by the symbol– when we talk about the zero-vector we know that the symbol <span class="math inline">\(0\)</span> represents a list whose every entry is 0:</li>
</ol>
<p><span class="math display">\[
0 = (0,0,\cdots,0)
\]</span></p>
<ol start="2" style="list-style-type: decimal">
<li>An additive inverse for every vector– the unique element (list of numbers) that can be added to get back to 0.</li>
</ol>
<p>I want to stress that this is where the idea of <strong>data types</strong> matters a great deal. The symbol <span class="math inline">\(0\)</span> <strong>as a real number</strong> is the usual 0. On the other hand the symbol <span class="math inline">\(0\)</span> <strong>as a vector</strong> is a list of <span class="math inline">\(0\)</span>’s. To add insult to injury. The symbol <span class="math inline">\(0\)</span> <strong>as an integer</strong> is <strong>NOT</strong> the same things as <span class="math inline">\(0\)</span> <strong>as a real number</strong>, etc. <em>EXCEPT</em>: since there is a natural inclusion of the integers into the real numbers we usually <em>bend the rules</em> a bit and consider an integer 0 to be the same thing as a real number 0.</p>
<p>Most computer language perform an automatic <strong>type conversion</strong>. Under the hood, an integer 0 in R (which we can designate as 0L) is not the same bit configuration as a <code>double</code> 0. But when the two are compared using the <code>==</code> comparison the language automatically converts the the <strong>least restrictive</strong> data type. Notice:</p>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre><code>## [1] TRUE</code></pre>
Look and see what happens if you compare “0” to 0:
<div class="tutorial-exercise" data-label="convert-to-character" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.checker":"NULL"}</script>
</div>
</div>
<div id="section-more-properties-of-vectors" class="section level3">
<h3>More properties of vectors</h3>
<p>We also need the following properties for <strong>vector addition</strong>:</p>
<ol style="list-style-type: decimal">
<li>Vector addition needs to be commutative: <span class="math inline">\(A+B = B+A\)</span></li>
<li>Vector addition needs to be associative: <span class="math inline">\((A+B)+C = A + (B+C)\)</span></li>
</ol>
<p>We also require there to be a <strong>scalar addition</strong> AND <strong>scalar multiplication</strong>. The key thing is that these scalar operations must <strong>distribute</strong> with vector addition:</p>
<ol style="list-style-type: decimal">
<li>a(A+B) = aA + aB</li>
<li>(ab)A = a(bA)</li>
<li>(a+b)A = aA + bA</li>
</ol>
<p>Finally, I’ll remark that we are defining a vectora space using <span class="math inline">\(\mathbb{R}\)</span> as the scalars. This is called a **vector space over <span class="math inline">\(\mathbb{R}\)</span>.</p>
<p>Not just any numeric system can fill the roll of being the scalars (for those who are interested, the scalars need to be a <strong>field</strong>, but if you don’t know what that means don’w worry about it), but we’ll ignore those details for now. Just notice that the following must also hold:</p>
<ol style="list-style-type: decimal">
<li>0A = 0</li>
<li>1A = A</li>
</ol>
</div>
</div>
<div id="section-data-as-vector" class="section level2">
<h2>data as vector</h2>
<p>Consider a numeric, statistical variable. It would not be out of place to think of it as a <strong>column</strong> in a <strong>table</strong> of data. R’s <code>data.frame</code> (and <code>tidyverse</code>’s <code>tibble</code>) are data types designed to deal with this abstraction. Base Python does not have an equivalent to <code>data.frame</code>, but the <code>Panda</code> package does. Let’s see a few examples:</p>
<div id="section-centered-data" class="section level3">
<h3>centered data</h3>
<p>Consider a datavector <span class="math inline">\(X=(x_1, x_2, \ldots, x_n)\)</span>. We can calculate the real value <span class="math inline">\(\overline{X} = \frac{1}{n}\sum x_i\)</span>. We can embed the real value <span class="math inline">\(\overline{X}\)</span> into the vector <span class="math inline">\(\overline{X} = (\overline{X}, \overline{X},\ldots,\overline{X})\)</span> (I’m using the same symbol for both… so that’s a bit confusing… just notice that <span class="math inline">\(\overline{X}\)</span> on the left-hand-side of <span class="math inline">\(=\)</span> is a vector and the <span class="math inline">\(\overline{X}\)</span>’s on the right-hand-side are real values) Then <strong>as vectors</strong> <span class="math inline">\(X-\overline{X}\)</span> represents a new data-set in which the average value of <span class="math inline">\(X\)</span> was subtracted from every one of the original entries.</p>
<p>This is called <strong>centering</strong> the data because the average of the new data set is 0. See for yourself:</p>
<p><span class="math display">\[
\begin{aligned}
X &amp;= (1,2,3)\\
\overline{X} &amp;= \frac{1+2+3}{3}\\
&amp;= 2\\
X - \overline{X} &amp;= (1-2,2-2,3-2)\\
&amp;=(-1,0,1)
\end{aligned}
\]</span></p>
<p>Clearly the average of the last expression is 0.</p>
</div>
</div>
<div id="section-matrices" class="section level2">
<h2>Matrices</h2>
<p>A matrix is a multidimensional array. In some languages it is an array <em>of</em> arrays. In R, a matrix, is, under the hood, just an array with some meta data (called an <code>attribute</code>) that determines the <strong>dimension</strong> of an array.</p>
<p>Let’s look at an example:</p>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10</code></pre>
<p>Notice that the variable <code>mat</code> is build from the sequence <code>1:10</code> Pay special attention to the ORDER of the original sequence and the order in the matrix.</p>
<p>(For the Computer Science students… this is called <strong>column major</strong>. Some languages use <em>row major</em> and some use <em>col major</em>)</p>
<p>A matrix, in R, can be accessed using the <code>[row,col]</code> expression:</p>
<pre><code>## [1] 6</code></pre>
<p>Individual rows can be accessed by leaving out the “col” number. Similarly for columns:</p>
<pre><code>## [1]  2  4  6  8 10</code></pre>
<pre><code>## [1] 5 6</code></pre>
<p>The <strong>transpose</strong> of a matrix swaps the rows and columns:</p>
<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## [3,]    5    6
## [4,]    7    8
## [5,]    9   10</code></pre>
<p>In Python we use nested lists and <strong>generator notation</strong> to access columns</p>
<pre><code>## 9</code></pre>
<pre><code>## [6.7, 8, 9, 10]</code></pre>
<pre><code>## [3, 9]</code></pre>
<p>Read <a href="https://socialsciences.mcmaster.ca/jfox/Books/Applied-Regression-2E/Appendices.pdf">B.1 through B.2</a> from John Fox’s Appendex pdf.</p>
<p>Now, in R,</p>
<p>Create two 2x5 matrices and assign them the variable <span class="math inline">\(A1\)</span> and <span class="math inline">\(A2\)</span> respectively.</p>
<p>The sum of the entries in <span class="math inline">\(A1\)</span> should be 5 and all the values should be different. The values in <span class="math inline">\(A2\)</span> can be whatever you like, but they can’t all be 0</p>
<p>Similarly make a 5x2 <span class="math inline">\(B\)</span> that is <strong>Not</strong> the tranpose of <span class="math inline">\(A1\)</span> or <span class="math inline">\(A2\)</span>.</p>
<p>Make two <strong>column vectors</strong> (which are matrices with 1 column) of size 5x1. Call them <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span></p>
<p>Points:</p>
<ul>
<li>1 point for each matrix</li>
<li>1 point for assigning the sum of <span class="math inline">\(A1\)</span> and <span class="math inline">\(A2\)</span> to <code>mat.sum</code></li>
<li>1 point for assigning the difference of <span class="math inline">\(B1\)</span> and <span class="math inline">\(B2\)</span> to <code>mat.diff</code></li>
<li>1 point for assigning <span class="math inline">\(-2A1\)</span> to <code>mat.scaled</code></li>
<li>1 point for assigning the transpose of <span class="math inline">\(A1\)</span> to <code>mat.transpose</code></li>
<li>1 point for assigning the matrix product <span class="math inline">\(A1B1\)</span> to <code>mat.product</code></li>
<li>1 point for assigning the value of <span class="math inline">\(A1v\)</span> to <code>y</code></li>
<li>1 point for calculating the <strong>dot product</strong> of <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span></li>
</ul>
<p>You will find that R has a <strong>matrix multiplication</strong> operation <code>%*%</code>.</p>
<div class="tutorial-exercise" data-label="matrix-1" data-caption="Code" data-completion="1" data-diagnostics="1" data-startover="1" data-lines="0">
<script type="application/json" data-opts-chunk="1">{"fig.width":6.5,"fig.height":4,"fig.retina":2,"fig.align":"default","fig.keep":"high","fig.show":"asis","out.width":624,"warning":true,"error":false,"message":true,"exercise.df_print":"paged","exercise.checker":"NULL"}</script>
</div>
<p>Now read <a href="https://socialsciences.mcmaster.ca/jfox/Books/Applied-Regression-2E/Appendices.pdf">B.1.3</a></p>
<p>Use the R function <code>solve</code> to find the inverse to <code>mat</code>. Assign it to the variable <code>inv</code>. Test that <code>mat%*%inv</code> = <code>inv%*%mat</code> is approximately <span class="math inline">\(I_4\)</span>. Note… that floating point arithemtic will ensure that desired inverse will not <em>quite</em> match <span class="math inline">\(I_4=\)</span><code>diag(1,4)</code>. But it will be close (try rounding the product to 3 places and see what happens)</p>
<p>It is good practice to put any <code>solve()</code> funcion inside of <code>try()</code> because many matrices are <strong>singular</strong> (non-invertible).</p>
<p>###Programming challenge</p>
<p>This is an <em>optional</em> challenge (difficulty 5 math points 15 csci points)</p>
<p>Write R code to show each step in Gaussian elimination for a 3x3 matrix(reread <a href="https://socialsciences.mcmaster.ca/jfox/Books/Applied-Regression-2E/Appendices.pdf">B.1.3</a> ) BONUS(+5 csci points): Make your code work for an <span class="math inline">\(nxn\)</span> matrix.</p>
</div>
<div id="section-lines-of-best-fit" class="section level2">
<h2>Lines of best fit</h2>
<p>(Primarily review)</p>
<p>Consider a dataset comprised of two variables. We will consider one to the <strong>response</strong> variable and the other to be the <strong>explantory</strong> variable.</p>
<p>The closeness of the data to fitting on a straight line when displayed as a scatterplot is measured by the <strong>correlation coefficient</strong> which is symbolized by the letter <span class="math inline">\(r\)</span>. This is a <strong>statistic</strong> (meaning that it is a number calculated from a sample) and it estimates a <strong>parameter</strong> (meaning a number that describes the distribution from which the sample was drawn).</p>
<p>If we let <span class="math inline">\(x_i\)</span> and <span class="math inline">\(y_i\)</span> denote the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> values for the <span class="math inline">\(i\)</span>th observation in the data-set and we let <span class="math inline">\(n\)</span> represent the number of obesrvations. Then we can define</p>
<p><span class="math display">\[
\begin{aligned}
\overline{X}&amp;=\frac{\sum_{i=1}^n x_i}{n}\\
\overline{Y}&amp;=\frac{\sum_{i=1}^n y_i}{n}\\
s_x^2 &amp;= \frac{\sum(x_i-\overline{X})^2}{n-1}\\
s_y^2 &amp;= \frac{\sum(y_i-\overline{Y})^2}{n-1}\\
r &amp;= \frac{1}{n-1}\large\sum\frac{(x_i-\overline{X})}{s_x}\frac{(y_i-\overline{Y})}{s_y}\\
b_1&amp;=\frac{s_y}{s_x}r\\
b_0&amp;=b_1*\overline{X} - \overline{Y}
\end{aligned}
\]</span></p>
<p>A few things to notice:</p>
<p><span class="math display">\[
\begin{aligned}
\sum(x_i-\overline{X}) &amp;= \sum x_i - \sum \overline{X} \\
&amp;= n\overline{X} - n \overline{x} \\
&amp;= 0
\end{aligned}
\]</span></p>
<p>Also</p>
<p><span class="math display">\[
\begin{aligned}
s_x^2 &amp;= \frac{\left|X-\overline{X}\right|^2}{n-1}\ \textrm{where }\overline{X} \textrm{ is a constant vector and }X\textrm{ is the data vector}\\
r &amp;= \frac{1}{n-1}\sum \frac{(x_i - \overline{X})}{s_x}\frac{(y_i - \overline{Y})}{s_y}\\
&amp;= \frac{1}{n-1}\frac{\sqrt{n-1}}{\left|X-\overline{X}\right|}\frac{\sqrt{n-1}}{\left|Y-\overline{Y}\right|}\left((X-\overline{X})\cdot(Y-\overline{Y})\right)\\ 
&amp;= \cos(\theta)\ \textrm{ where }\cos(\theta)\textrm{ is angle between } X -\overline{X} \textrm{ and } Y - \overline{Y}\\ 
\end{aligned}
\]</span></p>
<p>So we can interpret <span class="math inline">\(r\)</span> as the angle between the <strong>centered</strong> datavectors.</p>
</div>
<div id="section-why-would-we-use-overlinex-to-represent-overlinexoverlinexldotsoverlinex" class="section level2">
<h2>Why would we use <span class="math inline">\(\overline{X}\)</span> to represent <span class="math inline">\((\overline{X},\overline{X},\ldots,\overline{X})\)</span></h2>
<p>Just as we have a natural embedding of <span class="math inline">\(\mathbb{Z} \subset \mathbb{R}\)</span> there is a natural way of embedding <span class="math inline">\(\mathbb{R}^n\)</span> into the <span class="math inline">\(n \cross n\)</span> matrices. In particular, we take the <span class="math inline">\(n\)</span> elements in the vector and use them as the <strong>main diagonal</strong>. We could, of course use the vector as a column vector or a row vector, but doing it as the main diagonal has the following advantages:</p>
<ul>
<li>Addition remains componentwise</li>
<li>Multiplication remains componentwise</li>
</ul>
<p>Furthermore, the <strong>identity matrix</strong> is the matrix comprised of all 1’s on the diagonal. So there is a natural identification already of <span class="math inline">\(1 = (1,1,\ldots,1)\)</span>. And, in particular, We have a natural embedding of <span class="math inline">\(\mathbb{R} \subset \mathbb{R}^n \subset \textrm{Mat}_n(\mathbb{R})\)</span> that retains all the properties of scalar multiplication as well as vector addition.</p>
<p>This is also consistent with the way that R treats expressions. Notice that the two expressions below have the same output:</p>
<pre><code>## [1] -1  0  1</code></pre>
<pre><code>## [1] -1  0  1</code></pre>
</div>
<div id="section-more-structure" class="section level2">
<h2>More structure</h2>
<p>For machine learning purposes we are going to need to be able to compare vectors– not just to decide if they are the same or different, but to be able to assess <strong>how different</strong> two vectors are from each other. There are two types of mathematical machinery that makes this possible. The first is a <strong>Norm</strong>. This is a function that assigns to every vector a length. To be consistent with our usual definition of length it must have a few properties (which I will detail below).</p>
<p>The second idea is a way to measure the <strong>distance</strong> between two vectors. In math speak this is a function that takes two vectors as input and generates a single non-negative real number as output. In the interests of generality the properties of this function (discussed below) are as “loose” as possible and this means that some distance functions can behave in unexpected ways… <em>so be careful</em>!</p>
<p>A <strong>norm</strong> is a better fit for vector spaces because (as you will see shortly) it must respect “scalar multiplication”. In other words, the norm of <span class="math inline">\(2X\)</span> is twice the norm of <span class="math inline">\(X\)</span>. However, the properties of the distance function do <strong>not</strong> require that <span class="math inline">\(d(2X,2Y)=2d(X,Y)\)</span>.</p>
<p>For every norm there is a corresponding distance function <em>does</em> have the property that for every real <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(d(\alpha x, \alpha y) = \left|\alpha\right| d(x,y)\)</span>. And for every distance function with this property there is a corresponding norm so you could, if you wanted, consider vector spaces with a norm to be equivalent to vector spaces with a distance function that <strong>respects scalar multiplication</strong>.</p>
<div id="section-metric-space" class="section level3">
<h3>metric space</h3>
<p>We will think of a metric space as a vector space (over <span class="math inline">\(\mathbb{R}\)</span>) along with a concept of <strong>distance</strong>. In order for our idea of distance to make sense we’ll require the mathematical machinery (a function) to take two vectors as input and produce a real number as output… even more we will require that the output be <strong>non-negative</strong>. Let’s call this function <span class="math inline">\(d\)</span> and require that it has the following properties:</p>
<ul>
<li><span class="math inline">\(d(X,Y) \ge 0\)</span></li>
<li><span class="math inline">\(d(X,Y)=0 \textrm{ iff }X=Y\)</span></li>
<li><span class="math inline">\(d(X,Y) = d(Y,X)\)</span></li>
<li><span class="math inline">\(d(X,Y) + d(Y,Z) \le d(X,Z)\)</span> (the <strong>triangle inequality</strong>)</li>
</ul>
<p>A vector space with a function satisfying these conditions is known as a <strong>metric space</strong>.</p>
<p>We will encounter a large variety of metric spaces in data science and machine learning.</p>
<p>The usual way of determining distance (that you learned in high school and elementary school) is called the <strong>Euclidean Metric</strong>:</p>
<p><span class="math display">\[
d(X,Y) = \sqrt{(x_1 - y_1)^2 + (x_2 - y_2)^2 + \cdots + (x_n - y_n)^2}
\]</span></p>
<p>Consider some <strong>constraints</strong> placed upon <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> that restrict their possible values. Since the <span class="math inline">\(\sqrt{}\)</span> function and the <span class="math inline">\(x^2\)</span> functions are <strong>order preserving</strong> for non-negative values the extrema of <span class="math inline">\(d(X,Y)\)</span> is the same as the extrema for <span class="math inline">\(d(x,y)^2\)</span>. Hence the linear regression “line of best fit” is very closely associated to this particular metric.</p>
</div>
<div id="section-the-norm" class="section level3">
<h3>The norm</h3>
<p>The norm is frequently symbolized with single (or double) vertical lines:</p>
<ul>
<li><span class="math inline">\(\left|X \right|\)</span></li>
<li><span class="math inline">\(\left\| X \right\|\)</span></li>
</ul>
<p>The norm must satisfy these properties:</p>
<ul>
<li><span class="math inline">\(\left\|X\right\| \ge 0\)</span> and <span class="math inline">\(\left\|X\right\| = 0 \Leftrightarrow X=0\)</span> (vectors, except for 0, have positive length)</li>
<li><span class="math inline">\(\left\|X+Y\right\|\le \left\|X\right\| + \left\|Y\right\|\)</span> (respect the triangle!)</li>
<li><span class="math inline">\(\left\|\alpha X\right| = \left|\alpha\right|\left\|X\right\|\)</span> (respect scaling)</li>
</ul>
<p>We can define a distance from the norm as follows: <span class="math display">\[d(X,Y) = \left\|X-Y\right\|\]</span></p>
<p>It’s worth spending a bit of time to ensure that the distance axioms are satisfied… (but they are)</p>
<p>When the metric respects scaling then the following defines a valid norm:</p>
<p><span class="math display">\[\left\|X\right\| = d(X,0) \]</span></p>
<p>The original metric can, frequently, be regained from the norm But other metrics are possible:</p>
<p>For example:</p>
<p><span class="math display">\[
d(X,Y) = \sqrt[3]{(x_1 - y_1)^3 + (x_2 - y_2)^3 + \cdots + (x_n - y_n)^3}
\]</span></p>
</div>
</div>
<div id="section-calculus" class="section level2">
<h2>Calculus</h2>
<p>We are not going to need to master all of calculus for this course (although it’s not a bad idea if you want to understand the theory behind many of the technologies that we’ll be using). However, we are going to need to understand a few idea that came from calculus.</p>
<p>Let’s start by using this as an excuse to get a bit more practice with our R coding. We’ll be focusing on writing computer functions <strong>and</strong> using <strong>base R graphics</strong>. You might want to review the following:</p>
<ul>
<li>How to make a function in R</li>
<li>The <code>curve()</code> function in R</li>
</ul>
<p>I’ll start R-ifying the following mathematical expression:</p>
<p><span class="math display">\[
f(x) = x^2 - 3x +2
\]</span> Here’s how I could express this in R:</p>
<p>Notice that now I can use R to calculate the value of expressions like <span class="math inline">\(f(2)\)</span> and <span class="math inline">\(f(-1)\)</span>:</p>
<pre><code>## [1] 0</code></pre>
<pre><code>## [1] 6</code></pre>
<p>I can also use <code>curve()</code> to easily graph the function from <span class="math inline">\(x=-1\)</span> to <span class="math inline">\(x=3\)</span>:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-17-1.png" width="624" /></p>
<p>Recall, that in algebra you spent a great deal of time learning how to <strong>solve</strong> an equation like:</p>
<p><span class="math display">\[
f(x) = 0
\]</span></p>
<p>Graphically this is equivalent to plotting the following two functions and finding the x-values at which they cross:</p>
<p><span class="math display">\[
\begin{aligned}
y &amp;= x^2 - 3x + 2\\
y &amp;= 0
\end{aligned}
\]</span></p>
<p>Here is the graph: <img src="Math-Background_files/figure-html/unnamed-chunk-18-1.png" width="624" /></p>
<p>It certainly looks as if <span class="math inline">\(x=1\)</span> and <span class="math inline">\(x=2\)</span> are the solutions…. let’s check:</p>
<pre><code>## [1] 0</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Yep… although we need to be careful. R certainly things that <span class="math inline">\(x=1.00000000000000000001\)</span> is also a solution to the equation:</p>
<pre><code>## [1] 0</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Remember that any expression involving <code>==</code> and the comparison of two decimal expressions in R can be problematic. Try to remember (we discussed it in Intro to Data Science) why the following R expressions return the values that they do:</p>
<pre><code>## [1] 0.3</code></pre>
<pre><code>## [1] 0.3</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>The only way to be perfectly certain that you have an expression representing the <em>exact</em> answer is to use the techniques of mathematics… on the other hand… in most real-world situations being <em>very close</em> to the real answer is sufficient. In any event, in our situation, we can use a bit of algebra:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp;= x^2 - 3x + 2\\
&amp;=(x-2)(x-1)
\end{aligned}
\]</span></p>
<p>This is clearly satisfied (precisely) when <span class="math inline">\(x=1\)</span> or <span class="math inline">\(x=2\)</span>.</p>
<p>Create a function that plots the graph of <span class="math inline">\(f(x) = 2x^2 - 3x + 1\)</span> AND has a horizontal line at <span class="math inline">\(y=0\)</span>. (graph so that BOTH solutions appear)</p>
<p>Estimate the solutions from the graph. (Hint– one will be an integer and the other will be a rational number).</p>
</div>
<div id="section-numeric-approximation" class="section level2">
<h2>Numeric approximation</h2>
<p>Now how would I go about trying to find a good-enough solution to the equation if I didn’t know the algebra?</p>
<p><strong>First</strong>, we are not going to worry much about doing it efficiently. From the graph we can see that the solutions are definitely in the interval <span class="math inline">\([0,1.5]\)</span>. We might recall from algebra that a polynomial of degree <span class="math inline">\(n\)</span> has, at most, <span class="math inline">\(n\)</span>-real solutions… so since this polynomial is of degree 2, we know we’ve found all our solutions.</p>
<p>So… Let’s try <strong>every</strong> value between <span class="math inline">\(0.05\)</span> and <span class="math inline">\(1.55\)</span> spaced out by 0.1 (if we did it from 0 to 1.5 we would find the true values of the zeros immediately… but that’s not the purpose here)</p>
<p>Let’s look at our sample points graphically and then examine the y-values numerically:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-23-1.png" width="624" /></p>
<pre><code>##  [1]  0.855  0.595  0.375  0.195  0.055 -0.045 -0.105 -0.125 -0.105 -0.045
## [11]  0.055  0.195  0.375  0.595  0.855  1.155</code></pre>
<p>Look at the <strong>signs</strong> of the <span class="math inline">\(y\)</span>-valeus. They change from positive to negative. Let’s make a quick table of these values. I will use <code>rbind</code> so that the table fits more comfortably in this RMarkdown document, but that has the disadvantage that ALL entries <strong>in a column</strong> must be of the same data-type– that will rpoduce a data.frame in which all the values are numeric and we’ll lose the integer property that one would expect in an index. For real work <code>cbind()</code> or <code>data.frame()</code> is a better choice.</p>
<p>Notice that at index 5 to index 6 the <span class="math inline">\(y\)</span>-values change sign (this happens at <span class="math inline">\(x=0.45\)</span> and <span class="math inline">\(x=0.550\)</span>). A similar issue occurs between index 10 and index 11 (<span class="math inline">\(x=0.95\)</span> and <span class="math inline">\(x=1.15\)</span>) although this time we are transition between negative and positive.</p>
<p>If a function is well-behaved (some of you may be familiar with the term <strong>continuous</strong>) then we are <strong>guaranteed</strong> that the function does not “skip” values. In other words we know that between <span class="math inline">\(x=0.45\)</span> and <span class="math inline">\(x=0.55\)</span> the function takes on ALL possible values (at least once… possibly more than once) of <span class="math inline">\(f(0.45)=0.055\)</span> and <span class="math inline">\(f(0.550) = -0.045\)</span>. In particular we know there must be some <span class="math inline">\(x \in [0.45,0.55]\)</span> such that <span class="math inline">\(f(x) = 0\)</span>. That means we have an upper and lower bound on <strong>at least one</strong> solution.</p>
<pre><code>##        [,1]  [,2]  [,3]  [,4]  [,5]   [,6]   [,7]   [,8]   [,9]  [,10]
## index 1.000 2.000 3.000 4.000 5.000  6.000  7.000  8.000  9.000 10.000
## x     0.050 0.150 0.250 0.350 0.450  0.550  0.650  0.750  0.850  0.950
## y     0.855 0.595 0.375 0.195 0.055 -0.045 -0.105 -0.125 -0.105 -0.045
##        [,11]  [,12]  [,13]  [,14]  [,15]  [,16]
## index 11.000 12.000 13.000 14.000 15.000 16.000
## x      1.050  1.150  1.250  1.350  1.450  1.550
## y      0.055  0.195  0.375  0.595  0.855  1.155</code></pre>
<p>So we know that there is one solution between <span class="math inline">\(x=0.45\)</span> and <span class="math inline">\(x=0.55\)</span> and another between <span class="math inline">\(x=0.95\)</span> and <span class="math inline">\(x=1.15\)</span>. So this gives us one <strong>algorithm</strong> for finding solutions:</p>
<p>Pick a lower limit for <span class="math inline">\(x\)</span>, pick an upper limit for <span class="math inline">\(x\)</span>. Calculate all <span class="math inline">\(y\)</span> values for a sequence of <span class="math inline">\(x\)</span> values between these limits and look for changes in sign. For every change in sign, repeat the process with the more precise lower limits and the more precise upper limits <strong>and</strong> a sequence of <span class="math inline">\(x\)</span> values that are closer together. Repeat until the desired level of accuracy is achieved. Notice that the key to making htis work is that the evaluated value of one limit is negative and the other is positive.</p>
<p>One approach I could take is to apply the function to a sequence, find the number that is closest to zero and then look on either side to see if there is a sign change… any result that is 0 would end the process immediately.</p>
<p>I will use the fact that R can pass functions just like any other argument:</p>
<p>Now it’s your turn to write a function. Call it <code>find.zero()</code>. Use a <code>while()</code> loop and the <code>approximate.zero()</code> function that we just wrote to find a zero to the desired level of accuracy. If there are no sign change in the initial probe then return an NA.</p>
<p>I want to stress that this is a <strong>terrible</strong> way to find the zeros. Here are a few reasons why:</p>
<ul>
<li>We are calculating the value of our function for lots of unnecessary values.</li>
<li>We are making a sequence of x values independent of the behavior of the function</li>
</ul>
<p>More sophisticated approaches can be produced based around techniques you’ll see (or have seen) in Calc II such as Newton’s method. Without going into any technical details the idea in Newton’s method is to make a guess for the zero… then use the <strong>rate of change</strong> of the function near that guess to make a better guess.</p>
<p>Let’s put that idea aside– I want to continue using this simple example to provide some background for other important ideas.</p>
<p>First off… our approach to approximating the zero is a <strong>grid based</strong> approach. You’re probably used to thinking of a grid as being a two-dimensional thing like this:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-26-1.png" width="624" /></p>
<p>But what we did was the one-dimensional equivalent.. namely we found a set of <strong>equally spaced</strong> <span class="math inline">\(x\)</span>-values, starting at <span class="math inline">\(\textrm{lower}\)</span> and proceeding to <span class="math inline">\(\textrm{upper}\)</span>:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-27-1.png" width="624" /></p>
<p>What we did was, in essence, <strong>sampling</strong>. We choose sample locations, applied the function and then looked to see what we found. Rembmer our earlier function <span class="math inline">\(f(x) = x^2 - 3x + 2\)</span>:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-28-1.png" width="624" /></p>
<p>The dark circles along the bottom represent the <span class="math inline">\(x\)</span>-values for which we calculated the function. The light blue circles on the graph are the corresponding <span class="math inline">\((x,y)\)</span> pairs. We’re looking for the <strong>zeros</strong> of the function… so we want <span class="math inline">\(x\)</span>-values who’se corresponding point on the graph intersects <span class="math inline">\(y=0\)</span>. I purposefully left off the numeric values of the 10 <span class="math inline">\(x\)</span>-values used in this example.</p>
<p>But notice that we are using a grid to probe the value of the function at equally spaced inputs (the corresponding outputs) are, in general <strong>NOT</strong> equally spaced.</p>
<p>So our basic approach to approximating the zeros was</p>
<p><span class="math display">\[
\begin{aligned}
\textrm{Determine sample locations} &amp;\rightarrow \textrm{Evaluate Function}\\
&amp;\rightarrow \textrm{Determine new sample locations}
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\textrm{Repeat until desired conditions are satisfied}
\]</span></p>
<p>This is an <strong>iterative</strong> approach. We don’t necessarily know in advance how many times we will need to repeat.</p>
<p>Efficiency considerations aside, this is <em>exactly</em> what computers are good at doing.</p>
<p>Let’s consider a similar, but somehwat different problem– namely finding the value at which our function achieves a minimum. We will apply the same basic idea as before, but this time, instead of looking for places where the sign is changing we want to identify places where the function is increasing and decreasing. We could find the <strong>average rate of change</strong> between two sample points as follows: <span class="math display">\[
\textrm{avg change} = \frac{f(\textrm{right}) - f(\textrm{left})}{\textrm{right}-\textrm{left}}
\]</span> Now I am going to do something a bit tricky. I’m going to make a <strong>function factory</strong>. THe idea is that you pass the function factory some information and it <strong>creates</strong> a new function baed on that information. So my function generator will take a function <span class="math inline">\(f\)</span> and a distance <span class="math inline">\(h\)</span> and make the following new function:</p>
<p><span class="math display">\[
f&#39;(x) = \frac{f(x+h)-f(x)}{h}
\]</span></p>
<p>Let’s call this the <strong>delta</strong> of <span class="math inline">\(f\)</span> with an increment of <span class="math inline">\(h\)</span>.</p>
<p>Play with this idea and build a function called f that calculates <span class="math inline">\(f(x)=x^2 - 3\)</span>. Then find the delta of <span class="math inline">\(f\)</span> with <span class="math inline">\(h=0.01\)</span></p>
<p>plot <span class="math inline">\(f\)</span> and <span class="math inline">\(h\)</span> on the same graph. Be sure to add light gray lines at <span class="math inline">\(x=0\)</span> and <span class="math inline">\(y=0\)</span>. How are the graphs of <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(h(x)\)</span> related to each other?</p>
<p><img src="Math-Background_files/figure-html/exercise%20derivative%20example-1.png" width="624" /></p>
<p>There is no clear relationship between of the 0’s of <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(h(x)\)</span>, however… the 0’s of <span class="math inline">\(h(x)\)</span> (there’s only 1), do seem to tell us something important about the graph of <span class="math inline">\(f(x)\)</span>. Let’s color code the graph of <span class="math inline">\(h(x)\)</span> and the graph of <span class="math inline">\(f(x)\)</span>. Let’s make the graphs “blue” when it is below the line <span class="math inline">\(y=0\)</span> and make it “red” when it is above <span class="math inline">\(y=0\)</span>. We’re not going to completely automate this process. But let’s think about strategies.</p>
<p>Strategy one: Use algebra to find the zeros of the functions, determine the signs of the function over various inputs… draw the curve piece-wise</p>
<p>Strategy two: Calculate a dense sequence of <span class="math inline">\(x\)</span>-values, find the corresponding <span class="math inline">\(y\)</span>-values for the various functions and plot… we’ll do that.</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-30-1.png" width="624" /></p>
<p>The key thing that you are seeing is that the graph of <span class="math inline">\(h(x)\)</span> tells us <strong>how <span class="math inline">\(f(x)\)</span> is changing</strong>:</p>
<ul>
<li><span class="math inline">\(h(x) &gt; 0 \Rightarrow f(x) \textrm{ increasing}\)</span></li>
<li><span class="math inline">\(h(x) &lt; 0 \Rightarrow f(x) \textrm{ decreasing}\)</span></li>
<li><span class="math inline">\(h(x) = 0 \Rightarrow f(x) \textrm{ contstant}\)</span> (for a moment)</li>
</ul>
<p>So how does the magnitude of <span class="math inline">\(h(x)\)</span> relate to the change in <span class="math inline">\(f(x)\)</span>? First let’s recall that our <span class="math inline">\(h(x)\)</span> is, basically recording the rate of change of <span class="math inline">\(f(x)\)</span>…. it’s an estimate, but because used a small value for the increment it will be pretty close to the real thing. The interesting thing is that the <strong>rate of change</strong> has a nice graphical interpretation…. so… let’s pick an <span class="math inline">\(x\)</span> value. I’m going to use <span class="math inline">\(x=-0.2\)</span>.</p>
<p>As you play with the slider below, notice that the x-values are changing– this is because I wrote the app to zoom-in on the point of interest. (I’ll explain more about what you’re seeing a bit later):</p>
<p><div class="form-group shiny-input-container">
<label class="control-label" for="deriv.x">X value</label>
<input class="js-range-slider" id="deriv.x" data-min="-2" data-max="2" data-from="-0.2" data-step="0.1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div class="form-group shiny-input-container">
<label class="control-label" for="increment">Increment:</label>
<input class="js-range-slider" id="increment" data-min="0.001" data-max="1" data-from="1" data-step="0.0001" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div class="form-group shiny-input-container">
<div class="checkbox">
<label>
<input id="avgChange" type="checkbox"/>
<span>Show average change line</span>
</label>
</div>
</div><div class="form-group shiny-input-container">
<div class="checkbox">
<label>
<input id="instantChange" type="checkbox"/>
<span>Show instant change line</span>
</label>
</div>
</div><div class="form-group shiny-input-container">
<div class="checkbox">
<label>
<input id="numerics" type="checkbox"/>
<span>Show numeric values</span>
</label>
</div>
</div><div id="dPlot" class="shiny-plot-output" style="width: 100% ; height: 400px"></div></p>
<p>As you move the x-value you’re changing the location that you’re looking at the function. Notice that the <strong>average rate</strong> of change for a given increment (we’ll call it <span class="math inline">\(h\)</span> again… don’t confuse that with the function <span class="math inline">\(h(x)\)</span>) is changing:</p>
<p><span class="math display">\[
\begin{aligned}
\textrm{Average Rate of Change} &amp;= \frac{f(x+h) - f(x)}{(x+h)-x}\\
&amp;=\frac{f(x+h) - f(x)}{h}\\
\end{aligned}
\]</span></p>
<p>In other words the value of <span class="math inline">\(h(x)\)</span> is the <strong>change in y</strong> over the <strong>change in x</strong>. This is also known as the <strong>slope</strong> of a line.</p>
<p>You can see that as the increment gets smaller and smaller we’re zooming in more and more on the graph. Notice that the <em>zoomed in graph</em> looks increasingly like a straight line. The <strong>slope</strong> of that straight line is the <strong>instantaneous</strong> rate of change. It’s also known as the <strong>derivative</strong>.</p>
<p>So to recap.</p>
<ul>
<li>We use R to write a computer function that calculates a mathematical function <span class="math inline">\(f(x)\)</span></li>
<li>The R function <code>approximate.change()</code> is a function factory that makes a <strong>new function</strong> <span class="math inline">\(h(x)\)</span> that finds the <strong>average rate of change</strong> for an increment <span class="math inline">\(h\)</span>.</li>
<li>As the increment gets smaller and smaller, the average rate of change looks more like the instantaneous rate of change.</li>
<li>Zooming in on the graph near the point <span class="math inline">\((x,f(x))\)</span> will make the graph look increasingly like a straight line… the slope of that straight line is <strong>also</strong> the instantaneous rate of change</li>
<li>Zooming in on the graph and choosing a small increment for generating <span class="math inline">\(h(x)\)</span> are closely related to each other.</li>
<li>The choice of <span class="math inline">\(x\)</span>-value influences how “zoomed in” we need to be for the true graph to look like a straight line.</li>
</ul>
<p>Now let’s introduce vocabulary.</p>
<p>For a “good” function <span class="math inline">\(f(x)\)</span> the <strong>derivative</strong> of that function is the instantaneous rate of change for <span class="math inline">\(f(x)\)</span>. We denote this new functions as <span class="math inline">\(f&#39;(x)\)</span>. Our <strong>approximate change</strong> function will be very close to the true value of <span class="math inline">\(f&#39;(x)\)</span> for small increments…. how close we need to get will depend upon the value of <span class="math inline">\(x\)</span> for which we want the rate of change.</p>
<p>In calculus you learn how to find <span class="math inline">\(f&#39;(x)\)</span> exactly (in many situations). For example if <span class="math inline">\(f(x) = x^2 + 3\)</span> then <span class="math inline">\(f&#39;(x) = 2x\)</span>. The advantage of our approximation approach is that we only need to encode the mathematical function <span class="math inline">\(f(x)\)</span> in an R function… and then experiment with various increments until our approximate derivative gets close enough to the true answer. How do we know we are close enough? We keep making the increment closer to 0 and <strong>check</strong> the value near <span class="math inline">\(x\)</span>. When the approximation doesn’t change much… we’re <strong>probably</strong> close enough.</p>
<p><strong>WARNING:</strong> The techniques we’re developing here are horribly inefficient… they are for the purposes of pedagogy… <strong>Not</strong> for efficiently performing these calculations.</p>
<div id="section-finding-the-minimum" class="section level3">
<h3>Finding the minimum</h3>
<p>Let’s suppose that instead of finding the zero of a function we’re more interested in finding the minimum. We have a couple of options we can take</p>
<ol style="list-style-type: decimal">
<li>We could calculate the derivative and find the zeros for it</li>
<li>We could try something a bit different</li>
</ol>
<p>We’re going to go for the second one. This time, we’ll proceed as follows:</p>
<ol style="list-style-type: decimal">
<li>Take a guess (call this guess <span class="math inline">\(x\)</span>)</li>
<li>Calculate the derivative (rate of change) for the function at <span class="math inline">\(x\)</span></li>
<li>Use the derivative (rate of change) to adjust our guess</li>
</ol>
<p>It’s the last step that has all the magic. Notice that the closer we are to a minimum the <strong>lower</strong> the magnitude of the rate of change– at the minimum itself the rate of change is 0 (in our example).</p>
<p>The <span class="math inline">\(x\)</span>-axis comes with a natural sense of direction which we encode in a number line– lesser numbers are on the left and greater numbers are on the right. If the rate of change is <strong>negative</strong> the function is decreasing… and, if we’re hunting for a minimum, then we should increase the value of <span class="math inline">\(x\)</span> that we’re checking, on the other hand if the value of the function is increasing then we should decrease <span class="math inline">\(x\)</span>… since the desired minimum is to the left.</p>
<p>We will use the <strong>magnitude</strong> of the derivative to determine how far to move… since the sign is exactly backwards… let’s try this:</p>
<p><span class="math display">\[
\textrm{step at }x = -\frac{f&#39;(x)}{10}
\]</span> That 1/10 is just something to try:</p>
<p><div class="form-group shiny-input-container">
<label class="control-label" for="iterGuess">X value</label>
<input class="js-range-slider" id="iterGuess" data-min="1" data-max="28" data-from="1" data-step="1" data-grid="true" data-grid-num="9" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div class="form-group shiny-input-container">
<div class="checkbox">
<label>
<input id="iterShowLine" type="checkbox"/>
<span>Show Details</span>
</label>
</div>
</div><div id="iterPlot" class="shiny-plot-output" style="width: 100% ; height: 400px"></div></p>
<p>That took 28 iterations to get us to with <span class="math inline">\(x\pm0.01\)</span> of the desired value of <span class="math inline">\(x\)</span>. Note that if our step size was too large we could easily step <strong>over</strong> the minima and bounce back and forth between the two sides– getting increasingly farther away from our true goal. We could even encounter situations where we bounce back and forth between two values of <span class="math inline">\(x\)</span>.</p>
<p>I want to stress, one more time, that I’m providing inefficient examples for the purposes of increasing understanding…</p>
<p>Play around with these ideas a bit and see what you can find. Notice that I put an upper limit of 50 on the number of attempts the <code>iter()</code> function will employ when seeking a minimum– so you shouldn’t run into any infinite loops.</p>
<p>Also notice that if you were hunting for maximums you would need to use the <strong>opposite</strong> sign convention when updating your <span class="math inline">\(x\)</span>-guesses.</p>
</div>
<div id="section-adding-another-dimension" class="section level3">
<h3>Adding another dimension</h3>
<p>Now let’s think about a situation involving 2 input variables and 1 output variable. Or, in the language of statistics, 2 explanatory variables and 1 response variable.</p>
<p>Let’s start by considering a function that is related to statistics– the two dimensional equivalent of the bell-curve.</p>
<p>We will use the library <code>mvtnorm</code>. You may recall that continuous distributions have a density function that can be used to calculate probabilities for various events (review your introductory statistics material). The density function, in this case, takes two inputs and produces a single numeric output. The location of the graph is controlled by two parameters called the means (which are not included in this example because the graph really does look the same). There are <strong>two standard deviations</strong> one for each of the two inputs. Increasing the standard deviation for a variable increases the spread of the distribution (in that direction) and there is a corresponding widening of the bump in that direction.</p>
<p>The <strong>correlation</strong>, as you may recall, is a measure of how much knowledge about one variable’s value provides about the other. As this value gets closer to -1 (negative linear association) and +1 (positive linear association), the more concentrated the graph becomes. A correlation of 0 means that the two variable are completely independent.</p>
<p>The following Shiny applet will generate the graph of this distribution under various conditions</p>
<p><div class="form-group shiny-input-container">
<label class="control-label" for="x1.var">Standard deviation in x1</label>
<input class="js-range-slider" id="x1.var" data-min="0" data-max="3" data-from="1" data-step="0.1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div class="form-group shiny-input-container">
<label class="control-label" for="x2.var">Standard deviation in x2</label>
<input class="js-range-slider" id="x2.var" data-min="0" data-max="3" data-from="1" data-step="0.1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div class="form-group shiny-input-container">
<label class="control-label" for="covar">Correlation</label>
<input class="js-range-slider" id="covar" data-min="-0.9" data-max="0.9" data-from="0" data-step="0.1" data-grid="true" data-grid-num="9" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div class="form-group shiny-input-container">
<label class="control-label" for="theta">theta</label>
<input class="js-range-slider" id="theta" data-min="-45" data-max="45" data-from="0" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div class="form-group shiny-input-container">
<label class="control-label" for="phi">phi</label>
<input class="js-range-slider" id="phi" data-min="0" data-max="30" data-from="15" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div id="mvnPlot" class="shiny-plot-output" style="width: 600px ; height: 600px"></div></p>
<p><strong>Question:</strong> If knowledge of <span class="math inline">\(X_1\)</span> provides no information about <span class="math inline">\(X_2\)</span> then why do cross-sections for fixed values of <span class="math inline">\(X_1\)</span> have different heights?</p>
<p><strong>Answer:</strong> Do not confuse <strong>joint probability</strong> with <strong>conditional probability</strong>. The cross-section needs to be re-scaled to have an area of 1 again:</p>
<p><span class="math display">\[
P(X_2=a|X_1 = b) = \frac{P(X_1 =b \textrm{ and } X_2 = a)}{P(X_1 = b)}
\]</span></p>
<p>The special properties of the normal distribution ensure that that the re-scaled graphs all have the same shape!</p>
</div>
<div id="section-climbing-that-hill" class="section level3">
<h3>Climbing that hill</h3>
<p>We can apply a similar strategy towards finding a maximum or a minimum for this function, as we did earlier. but now we are faced with a more difficult challenge. The <strong>step</strong> (or <strong>increment</strong>) that we need must take into consideration TWO dimensions. We could go back to our grid-based approach (this time in 2D). To be more precise we could find an equally spaced collection of input variables– evaluate our function at all neighborhood points– pick the largest– and then for all four of the “square neighborhoods”, produce a finer grid and repeat the process… but this seems inefficient.</p>
<p>It would be nice to be able to somehow <em>follow the slope</em> (like we did in the 1D case). But what does that mean? In a graph like this there is not a 1-dimensional line that looks like the graph.. instead if you zoom in very closely the graph begins to look like a <strong>plane</strong>. To describe such a plane we have to describe <strong>two tilts</strong>: One for X and one for Y:</p>
<p><div class="form-group shiny-input-container">
<label class="control-label" for="partialX">Tilt in X:</label>
<input class="js-range-slider" id="partialX" data-min="-2" data-max="2" data-from="1" data-step="0.2" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div class="form-group shiny-input-container">
<label class="control-label" for="partialY">Tilt in Y:</label>
<input class="js-range-slider" id="partialY" data-min="-2" data-max="2" data-from="0" data-step="0.2" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div><div id="planePlot" class="shiny-plot-output" style="width: 100% ; height: 600px"></div></p>
<p>Consider that multinormal distribution whose graph you explored earlier. Let’s consider it to be the graph of <span class="math inline">\(z=f(x,y)\)</span>…. pick a point and imagine zooming closer and closer to that location… as you zoom in closer and closer to some fixed point <span class="math inline">\((x,y,f(x,y))\)</span>, the graph will increasingly look like the type of plane that you were manipulating in the last app. Both the <span class="math inline">\(x\)</span>-tilt and the <span class="math inline">\(y\)</span>-tilt will depend upon the function <span class="math inline">\(f(x,y)\)</span> and the input <span class="math inline">\((x,y)\)</span> chosen. We call <span class="math inline">\(x\)</span>-tilt the <strong>partial derivative with respect to <span class="math inline">\(x\)</span></strong> and the <span class="math inline">\(y\)</span>-tilt is the <strong>partial derivative with respect to <span class="math inline">\(y\)</span></strong>. The first represents the rate of change at <span class="math inline">\((x,y)\)</span> <strong>when one changes <span class="math inline">\(x\)</span></strong>. The second represents the rate of change at <span class="math inline">\((x,y)\)</span> <strong>when one changes <span class="math inline">\(y\)</span></strong>. These can be symbolized as <span class="math inline">\(\partial_x\)</span> and <span class="math inline">\(\partial_y\)</span> (you’ll see slightly different notation in your math class… but I want to keep this simple so I’m choosing to use this convention.)</p>
<p><span class="math display">\[
\begin{aligned}
\textrm{Approximate change in f(x,y) for changing }x &amp;= \frac{f(x+h,y)-f(x,y)}{\textrm{Distance between }(x+h,y)\textrm{ and }(x,y)}\\
&amp;= \frac{f(x+h,y)-f(x,y)}{h}\\
\textrm{Approximate change in f(x,y) for changing }y &amp;= \frac{f(x,y+h)-f(x,y)}{\textrm{Distance between }(x,y+h)\textrm{ and }(x,y)}\\
&amp;= \frac{f(x,y+h)-f(x,y)}{h}
\end{aligned}
\]</span> We can actually find a similar average rate of change along any vector <span class="math inline">\((a,b)\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
\textrm{Approximate change in f(x,y) along }(a,b) &amp;= \frac{f(x+a,y+b)-f(x,y)}{\textrm{Distance between }(x+a,y+b)\textrm{ and }(x,y)}
\end{aligned}
\]</span> We <em>could</em> come up with explicit formulas… but that’s something you’ll do in calculus… I just want to get the idea across. As the vector <span class="math inline">\((a,b)\)</span> is increasingly close to <span class="math inline">\((0,0)\)</span> We get closer to an <strong>instantaneous rate of change</strong> in the direction <span class="math inline">\((a,b)\)</span>.</p>
<p>This is known as the <strong>directional derivative</strong>. There are all sorts of interesting and important details that I’m sweeping under the rug, so if anything seems weird to you (I can think of a couple of things that I’m purposefully not discussing right now that might distrurb you), then please ask me about it in person.</p>
<p>But for now… imagine that you <strong>pick a direction</strong> (that we will describe as <span class="math inline">\((a,b)\)</span>) and find the approximate rate of change along <span class="math inline">\((a,b)\)</span> now consider scaling <span class="math inline">\((a,b)\)</span> closer and closer to 0… this will get us arbitrarily close to the rate of change in the direction <span class="math inline">\((a,b)\)</span> (again… this is the directional derivative in the direction <span class="math inline">\((a,b)\)</span>).</p>
<p>Now, if we are seeking the top of the hill… what we <strong>really</strong> want is the direction that travel from <span class="math inline">\((x,y)\)</span>. Rather surprisingly that direction lines up with <span class="math inline">\((a,b) = (\partial_x,\partial_y)\)</span>. This expression has another name too… it’s called the <strong>gradient</strong>.</p>
<p>So when you hear about the <strong>gradient descent</strong> technique… then you know that this idea is being used to find a minimum. We calculate (exactly <em>or</em> approximately), the gradient for a function at a specific input point. This provides us a direction the direction of steepest increase (the negative of this vector is the direction of steepest decrease), we use these values to decide the direction of our step and we take an appropriate scaled hop in that direction and check again… we continue until our directional vector is appropriate close to <span class="math inline">\((0,0)\)</span>. The advantage of this technique is that it applies equally well no matter HOW MANY input variables we’re using.</p>
<p><strong>Important NOTE:</strong> multilpying a function by -1 turns maximums into minimums and vice versa… so if you can find local minimums you can find local maximums and vice-versa.</p>
</div>
<div id="section-parameter-space" class="section level3">
<h3>Parameter Space</h3>
<p>We have already seen an example of a <strong>parameterized distribution</strong>. (The multivariate normal distribution example you played with earlier).</p>
<p>Let’s go back to the <strong>line of best fit</strong> that we all know and love from <strong>linear regression</strong>. A line is a parameterized <strong>model</strong> with two parameters:</p>
<ul>
<li>Intercept</li>
<li>Slope</li>
</ul>
<p>If didn’t already have the formula, we <em>could</em> apply these techniques to get pretty close to the line of best fit. Our function that we <strong>wish to minimize</strong> would be the sum of squares of the residuals. So we need our <strong>observations first</strong>, and then we could calculate the sum of squares of the errors… In other words: Two variables as input, one as output… Just exactly the sort of thing we’ve already been doing. Let’s give it a try with some random data… first, here’s the point cloud:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-40-1.png" width="624" /></p>
<p>I will invert the residuals function to make the minima (now a maxima) a bit easier to see (inverting it makes the minima a maxima… so look for the peak). Note– the slope is too gradual near the peak to be able to see easily, so I added the “exponentiate” option which will make the peak substantially easier to locate (but you might enjoy turning it off).</p>
<p>I’m also including a <strong>countour map</strong>. It shows the same basic information as the perspective plot but it does so in 2D– the lines on a contour map indicate <strong>level sets</strong>– These are places that all have the same “height”&quot; (aka have the same output). Exponentiation will control where the algorithm places the level sets… just play with it a bit… you’ll get the idea.</p>
<p><strong>Warning:</strong> The red dot representing the sum of squares for your choice of slope and intercept (in the left graph) is graphed AFTER the surfaced plot– this means it will always be visible– even if it should be hidden by the surface– this can make the behavior of the redpoint look a bit… odd.</p>
<p><div class="row">
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.intercept">Intercept</label>
<input class="js-range-slider" id="model.intercept" data-min="0.4" data-max="3.6" data-from="0" data-step="0.1" data-grid="true" data-grid-num="8" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.slope">Slope</label>
<input class="js-range-slider" id="model.slope" data-min="-0.4" data-max="5.1" data-from="1" data-step="0.1" data-grid="true" data-grid-num="9.16666666666667" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
</div><div class="row">
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.theta">Theta</label>
<input class="js-range-slider" id="model.theta" data-min="-180" data-max="180" data-from="6" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.phi">Phi</label>
<input class="js-range-slider" id="model.phi" data-min="-180" data-max="180" data-from="24" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
</div><div class="form-group shiny-input-container">
<div class="checkbox">
<label>
<input id="model.exponentiate" type="checkbox" checked="checked"/>
<span>Exponentiate</span>
</label>
</div>
</div><div class="row">
<div class="col-sm-8">
<div id="paramExplore" class="shiny-plot-output" style="width: 100% ; height: 400px"></div>
</div>
<div class="col-sm-4">
<div id="lineFit" class="shiny-plot-output" style="width: 100% ; height: 400px"></div>
</div>
</div><div id="paramContour" class="shiny-plot-output" style="width: 100% ; height: 400px"></div></p>
<p>The nice thing about a contour map is that whether you’re looking for a maximum or a minimum the view will be the same.</p>
<p>We used the <strong>sum of squares</strong> of the residuals in the last example– this ends up making a line that does a good job of saying where the “mean” of <span class="math inline">\(y\)</span> should be for a given <span class="math inline">\(x\)</span>. This approach does not really depend upon the distribution of the response variable, but it’s usefulness– as measured by being a good description of central tendencies, or as being able to make reasonable observations about the relationship between the explantory variables and the response variable may be compromised. Two of the first things you should check after building a linear model are</p>
<ul>
<li>That the residuals are normally distributed</li>
<li>That the variables are homooscedastic</li>
</ul>
<p>If the latter case is violated (which means that variance in <span class="math inline">\(y\)</span> depends upon the specific values of the explanatory variables), then we have two common approaches</p>
<ol style="list-style-type: decimal">
<li>Transform the response (or the explanatory variables) until the data is homoscedastic</li>
<li>Use a more sophisticated regression technique like Generalalized Linear Models.</li>
</ol>
<p>We’ll discuss both of those a bit. The first might be as simple as taking the log of the response values or raising it some variance stabilizing power (like a square root) before attempting regression. Interpreting the details of the model after such transformations can be challenging, but in many cases this is both easy and straighforward.</p>
</div>
</div>
<div id="section-using-a-different-measure-of-fit" class="section level2">
<h2>Using a different measure of fit</h2>
<p>However… it is possible for us to use different measures of fit. One example would be</p>
<p><span class="math display">\[
\sum \left|y_i - \widehat{y_i}\right|
\]</span> Here, instead of the sum of squares of the residuals, we are finding the sum of the absolute values of the residuals:</p>
<p><div class="row">
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.intercept2">Intercept</label>
<input class="js-range-slider" id="model.intercept2" data-min="0.4" data-max="3.6" data-from="0" data-step="0.1" data-grid="true" data-grid-num="8" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.slope2">Slope</label>
<input class="js-range-slider" id="model.slope2" data-min="-0.4" data-max="5.1" data-from="1" data-step="0.1" data-grid="true" data-grid-num="9.16666666666667" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
</div><div class="row">
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.theta2">Theta</label>
<input class="js-range-slider" id="model.theta2" data-min="-180" data-max="180" data-from="6" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.phi2">Phi</label>
<input class="js-range-slider" id="model.phi2" data-min="-180" data-max="180" data-from="24" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
</div><div class="form-group shiny-input-container">
<div class="checkbox">
<label>
<input id="model.exponentiate2" type="checkbox" checked="checked"/>
<span>Exponentiate</span>
</label>
</div>
</div><div class="row">
<div class="col-sm-8">
<div id="paramExplore2" class="shiny-plot-output" style="width: 100% ; height: 400px"></div>
</div>
<div class="col-sm-4">
<div id="lineFit2" class="shiny-plot-output" style="width: 100% ; height: 400px"></div>
</div>
</div><div id="paramContour2" class="shiny-plot-output" style="width: 100% ; height: 400px"></div></p>
<p>As before I have inverted the surface… you truly want the “lowest point”, but it’s easier to see what’s happening if we make this behave like we are seeking the highest point– the contour plot would looke identical– only the numbers labeling the contours would change sign– but the curves would remain the same. Interestingly, this measure produces a result that predicts the <strong>median</strong> of the <span class="math inline">\(y\)</span> values rather than the <strong>mean</strong>.</p>
<p>You’ll notice in this case that the surface showing the measure of best fit is a bit more peaked when non exponentiated– but the line ends up being pretty much identical– this is because the error distribution is symmetric so the mean and median are the same.</p>
<p>Let’s look at a different set of points where the distribution for each <span class="math inline">\(y\)</span>-value is not normal, but is instead a skewed distribution:</p>
<p><div class="row">
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.intercept3">Intercept</label>
<input class="js-range-slider" id="model.intercept3" data-min="0" data-max="8" data-from="0" data-step="0.1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.slope3">Slope</label>
<input class="js-range-slider" id="model.slope3" data-min="0" data-max="8" data-from="1" data-step="0.1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
</div><div class="row">
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.theta3">Theta</label>
<input class="js-range-slider" id="model.theta3" data-min="-180" data-max="180" data-from="6" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="model.phi3">Phi</label>
<input class="js-range-slider" id="model.phi3" data-min="-180" data-max="180" data-from="24" data-step="1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
</div><div class="form-group shiny-input-container">
<div class="checkbox">
<label>
<input id="model.exponentiate3" type="checkbox" checked="checked"/>
<span>Exponentiate</span>
</label>
</div>
</div><div class="row">
<div class="col-sm-8">
<div id="paramExplore3" class="shiny-plot-output" style="width: 100% ; height: 400px"></div>
</div>
<div class="col-sm-4">
<div id="lineFit3" class="shiny-plot-output" style="width: 100% ; height: 400px"></div>
</div>
</div><div id="paramContour3" class="shiny-plot-output" style="width: 100% ; height: 400px"></div></p>
<p>The usual lineof best fit is in blue, the fit to the model using this modified approach is, as usual, in red. The absolute value-of-the-residuals-approach is more robust– it is resistant to outliers.</p>
<p>##Mathematical aside Consider a set of numbers– what value has the property that it minimizes the sum of square of the distances? How would we even go about figuring that out? Well… first we find an equation that captures that value:</p>
<p><span class="math display">\[
\sum (x_i-x)^2
\]</span></p>
<p>If we take the derivative with respect to <span class="math inline">\(x\)</span> we get <span class="math inline">\(\sum -2(x_i-x)=-2\sum (x_i-x)\)</span>. If we want to minimize this value we need the derivative to be 0:</p>
<p><span class="math display">\[
\begin{aligned}
0 &amp;=-2\sum( x_i - x) \\
&amp;= \sum(x_i - x)\\
&amp;= \sum(x_i) - nx\\
nx &amp;= \sum(x_i)\\
x &amp;= \frac{\sum x_i}{n}\\
&amp;=\overline{x}
\end{aligned}
\]</span></p>
<p>Similarly for <span class="math inline">\(\sum \left|x_i-x\right|\)</span>. Let’s start by assuming that whatever the desired value for <span class="math inline">\(x\)</span> happens to be, it is <strong>not</strong> the same as any of the <span class="math inline">\(x_i\)</span>… if it WERE then we could remove those <span class="math inline">\(x_i\)</span> without changing the sum… since the difference <span class="math inline">\(x-x_i\)</span> would be 0 for those values. Thus the derivative is either +1 or -1 depending upon whether <span class="math inline">\(x\)</span> is above or below <span class="math inline">\(x_i\)</span>. Setting this to zero and separating the two parts out: Let <span class="math inline">\(i\)</span> denote the number of terms larger than <span class="math inline">\(x\)</span> and <span class="math inline">\(j\)</span> the number lower than <span class="math inline">\(x\)</span>: <span class="math display">\[
\begin{aligned}
0&amp;=\frac{d}{dx}\sum \left|x_k - x\right|\\
 &amp;= -\biggl(\sum_{\textrm{terms greater than x}}(-1)\biggr) + \sum_{\textrm{terms less than x}}(1)\\
&amp;=j-i\\
i&amp;=j
\end{aligned}
\]</span> Note that as <span class="math inline">\(X\)</span> changes the terms that take part in the LHS and in the RHS change and the function itself is only piecewise differentiable… but as long as <span class="math inline">\(x\)</span> is not any of the data points we’re safe and the equation holds. So we achieve a minimum when <span class="math inline">\(i\)</span>=<span class="math inline">\(j\)</span>… which means that the number of terms greater than <span class="math inline">\(x\)</span> is the same as the number less than <span class="math inline">\(x\)</span>. In fact… <span class="math inline">\(x\)</span> is not unique (which is one reason why we like the sum of squares– it <strong>is</strong> guaranteed to have a unique solution). If the number of observations is odd… then, of course, we need to make <span class="math inline">\(x\)</span> equal that middle observation… so then <span class="math inline">\(i=j\)</span> again and the solution IS unique.</p>
<p>Let’s think about this some more: Let’s move <span class="math inline">\(x\)</span> by the tiny amount <span class="math inline">\(\delta x\)</span>. Suppose that there are <span class="math inline">\(i\)</span> observations below <span class="math inline">\(x\)</span> and <span class="math inline">\(j\)</span> above. If <span class="math inline">\(\delta x\)</span> is negative then <span class="math inline">\(x\)</span> gets closer to those <span class="math inline">\(i\)</span> observations– and so the overall sum diminishes by <span class="math inline">\(\delta x)\)</span> for every one… hence a change of <span class="math inline">\((\Delta x)i\)</span> (recall that in this circumstance <span class="math inline">\(\delta x\)</span> is negative). Similarly, <span class="math inline">\(x\)</span> will move farther away from those observations… for a total change of <span class="math inline">\(-(\Delta x)j\)</span>. The overall change will then be <span class="math inline">\(\Delta x(i-j)\)</span>. Of course, when <span class="math inline">\(i=j\)</span> there is no change.</p>
<p>Write a function that takes two arguments:</p>
<ul>
<li><span class="math inline">\(x\)</span> which is the same <span class="math inline">\(x\)</span> as up above</li>
<li><span class="math inline">\(dat\)</span> which is a vector of the data values <span class="math inline">\((x_1, x_2, \ldots, x_n)\)</span></li>
</ul>
<p>call the function <code>.f</code>.<br />
<img src="Math-Background_files/figure-html/abs-exercise%20exercise-1.png" width="624" /></p>
<div id="section-ridge-regression" class="section level3">
<h3>ridge regression</h3>
<p>We have looked at 2 cost functions:</p>
<ul>
<li><span class="math inline">\(\sum \textrm{residuals}^2\)</span></li>
<li><span class="math inline">\(\sum \left|\textrm{residuals}\right|\)</span></li>
</ul>
<p>Another interesting approach tries to balance the accuracy with a restriction on the **parameters*</p>
<p><span class="math display">\[
\sum \textrm{residuals}^2 + \lambda \sum \textrm{parameter values}^2
\]</span> The real value <span class="math inline">\(\lambda\)</span> is a <strong>hyper parameter</strong>. When <span class="math inline">\(\lambda=0\)</span> we have the usual OLS (<strong>ordinary least sum of squares</strong>). Otherwise the sum of squares of the parameters influences the result.</p>
<p>This is called <strong>ridge regresssion</strong></p>
</div>
</div>
<div id="section-exponential-family" class="section level2">
<h2>Exponential Family</h2>
<p>An <strong>extremely</strong> general family of distributions… so general in fact that it is hard to get a good sense out of what can (or can’t) be done with the curve is the <strong>exponential family</strong>.</p>
<p>In order to do more sophisticated forms of regression we want to understand this family better. In order to do normal linear regression we want:</p>
<ul>
<li>The error to be normally distributed</li>
<li>with a mean of 0</li>
<li>with a variance that is independent of the fitted value</li>
</ul>
<p>You may recall that the latter condition is known as <strong>homoscedasticity</strong></p>
<p>We will explore the <strong>two-parameter</strong> family of exponential functions… but that’s misleading because we almost always pick <strong>three functions</strong> to shape the curve. Different choices for these curves correspond to different distributions. So let’s build up this expression piece by simple piece:</p>
<p><strong>A Line:</strong></p>
<p><span class="math display">\[y = mx + b\]</span></p>
<p>Which we would be more apt to write as</p>
<p><span class="math display">\[f(x) = mx + b\]</span></p>
<p>Here <span class="math inline">\(m\)</span> is the slope and <span class="math inline">\(b\)</span> is the intercept– these <em>constants</em> and their interpretions should be well-under stood to you.</p>
<p><strong>Complication one:</strong> We will be describing the distriubtion of the <em>response</em> variable, so we should use <span class="math inline">\(y\)</span>:</p>
<p><span class="math display">\[
f(y) = my + b
\]</span></p>
<p>We are going to call use a different symbol to represent <span class="math inline">\(m\)</span>… namely <span class="math inline">\(\theta\)</span>:</p>
<p><span class="math display">\[
f(y) = \theta y + b
\]</span></p>
<p><strong>Complication Two:</strong></p>
<p>We want to understand the distribution for <span class="math inline">\(y\)</span> <strong>given</strong> values for the explanatory variables, but we are NOT including them in our equation… all way have is <span class="math inline">\(m\)</span> and <span class="math inline">\(b\)</span>.</p>
<p>To make this work, mathematically we would like to (at least for now) consider situations where <span class="math inline">\(b\)</span> depends upon <span class="math inline">\(m\)</span>. We are going change our notation and call <span class="math inline">\(m\)</span> by the new symbol <span class="math inline">\(\theta\)</span>. We are also going to make the dependence of <span class="math inline">\(b\)</span> upon <span class="math inline">\(m\)</span> (now <span class="math inline">\(\theta\)</span>) explicit… FURTHERMORE we will use notation from conditional probability and (for technical reasons) we will use <span class="math inline">\(-\)</span> instead of <span class="math inline">\(+\)</span> for the intercept:</p>
<p><span class="math display">\[
f(y| \theta) = \theta y - b(\theta)
\]</span> So now we have a family of lines… pick a different value of <span class="math inline">\(\theta\)</span> (The slope) and we change the line under consideration… however we now need a function called <span class="math inline">\(b(\theta)\)</span> to determine the intercept.</p>
<p>We don’t explicitly include the dependence <span class="math inline">\(f(y|\theta, \textrm{function }b)\)</span>.</p>
<p>The choice of function for <span class="math inline">\(b()\)</span> and the value of <span class="math inline">\(\theta\)</span> will end up determining the expected value of <span class="math inline">\(y\)</span> (when we are done) building the distribution.</p>
<p>Even after we add all the other features to this model the expected value of <span class="math inline">\(y\)</span> (for a given value of <span class="math inline">\(\theta\)</span>) will be</p>
<p><span class="math display">\[
\mathbb{E}(y)=b&#39;(\theta)
\]</span> You don’t need to memorize this formula or anything… just know that the choice of <span class="math inline">\(b()\)</span> is determining where the center of the data will be.</p>
<p>We are also going to want to be able to control the <strong>scale</strong> (aka the variance) of <span class="math inline">\(y\)</span>. So we will add a new scaling parameter <span class="math inline">\(\phi\)</span> to our model (<span class="math inline">\(\phi\)</span> is known as the <strong>dispersion parameter</strong>):</p>
<p><span class="math display">\[
f(y|\theta,\phi) = \frac{\theta y - b(\theta)}{a(\phi)}
\]</span> Once <span class="math inline">\(\phi\)</span> is chosen this does nothing more (and nothing less) then verticall expand or shrink the graph of the line… the result is still a line.</p>
<p>Next we are going to <strong>exponentiate</strong> the right-hand side. This turns the curve into an exponential growth or exponential decay function:</p>
<p><span class="math display">\[
f(y|\theta,\phi) = \exp\biggl(\frac{\theta y - b(\theta)}{a(\phi)}\biggr)
\]</span> The problem is that this is not particularly useful. For one thing it won’t even be a distribution since the area under the curve won’t be 1.</p>
<p>We add one more function to the interior that depends upon <span class="math inline">\(y\)</span> and <span class="math inline">\(\phi\)</span>:</p>
<p><span class="math display">\[
f(y|\theta,\phi) = \exp\biggl(\frac{\theta y - b(\theta)}{a(\phi)}+c(y,\phi)\biggr)
\]</span></p>
<p>It’s that final function <span class="math inline">\(c()\)</span>, that determines the actual shape of the distribution… and it is this term that ensures that the total area under the curve is 0.</p>
<p>Our final function <span class="math inline">\(c\)</span> will depend upon both <span class="math inline">\(y\)</span> and <span class="math inline">\(\phi\)</span>. It can, in principle be any function… Think of it as a <strong>transformation</strong> of the line:<br />
<span class="math display">\[
f(y|\theta,\phi) = \frac{\theta y - b(\theta)}{a(\phi)}
\]</span></p>
<p>Before I go any further I need to draw your attention to a few details. First, as-written, the value of the density function <span class="math inline">\(f\)</span> will depend directly upon both <span class="math inline">\(b()\)</span> AND <span class="math inline">\(c()\)</span> so how can I say that the expected value of <span class="math inline">\(y\)</span> for a given <span class="math inline">\(x\)</span> will on depend upon <span class="math inline">\(b()\)</span> (namely <span class="math inline">\(\mathbb{E}(y)=b&#39;(\theta)\)</span>). This is because there is a <strong>hidden connection</strong> between our data and the values of <span class="math inline">\(\theta\)</span> and <span class="math inline">\(\phi\)</span>. We are looking for the <strong>distribution of best fit</strong>. It’s the value of <span class="math inline">\(\theta\)</span> and <span class="math inline">\(\phi\)</span> that are <strong>most consistent</strong> with the data. Just like that peak you saw when we looked sum of square of the residuals for various values of <span class="math inline">\(m\)</span> and <span class="math inline">\(b\)</span>. This is called the $maximum likelihood estimate** or <strong>MLE</strong> of the parameters. For this TERRIBLY complicated equation… the mean of <span class="math inline">\(y\)</span> will occur precisely at <span class="math inline">\(b&#39;(\theta)\)</span>.<br />
In any event… let’s do some graphing:</p>
<p><div class="row">
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="modelglm.theta">GLM theta</label>
<input class="js-range-slider" id="modelglm.theta" data-min="-10" data-max="10" data-from="1" data-step="0.1" data-grid="true" data-grid-num="10" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label class="control-label" for="modelglm.phi">GLM phi</label>
<input class="js-range-slider" id="modelglm.phi" data-min="0.1" data-max="5" data-from="1" data-step="0.1" data-grid="true" data-grid-num="9.8" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
</div>
</div>
</div><div class="row">
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label for="modelglm.a">a(phi)</label>
<input id="modelglm.a" type="text" class="form-control" value="0.5"/>
</div>
</div>
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label for="modelglm.b">b(theta)</label>
<input id="modelglm.b" type="text" class="form-control" value="theta^2/2"/>
</div>
</div>
<div class="col-sm-4">
<div class="form-group shiny-input-container">
<label for="modelglm.c">c(y,phi)</label>
<input id="modelglm.c" type="text" class="form-control" value="-y^2"/>
</div>
</div>
</div><div class="row">
<div class="col-sm-8">
<div id="paramGLMExplore" class="shiny-plot-output" style="width: 100% ; height: 400px"></div>
</div>
</div></p>
<p>Notice that for the default values given we have a curve that is, up to a constant multiple, the normal curve with mean <span class="math inline">\(\theta\)</span> and variance one. Change:</p>
<p><span class="math display">\[
\begin{aligned}
a(\phi)&amp;=\textrm{phi^2}\\
b(\theta)&amp;=\textrm{theta^2/2}\\
c(y,\theta) &amp;= \textrm{-y^2/2/phi^2}
\end{aligned}
\]</span></p>
<p>That is, essentially, the normal distribution with mean <span class="math inline">\(\theta\)</span> and variance <span class="math inline">\(\phi\)</span>. It’s not actually a density curve since the area under the curve is different from 1… but a few minor changes to the functions <span class="math inline">\(a(\phi), b(\theta),\)</span> and <span class="math inline">\(c(y,\phi)\)</span> would fix that issue.</p>
<p>Before proceeding, et’s consider what our ultimate goal actually is:</p>
<p>Given a point cloud associated to data– we’d like to be able to create a model that can be used to make reasonable predictions about the where the <strong>center</strong> of the reponse values should be. This value should depend upon the explanatory variables. It would be even better if we had a decent description for the response variable values associated to a given set of explanatory values. At a bare minimum we should be able to tell whether or not the mean and variance of those values is consistent with our model. In a better circumstance we’d like to be able to make confidence intervals.</p>
<p>Consider a situation where the y-values are Bernoulli (recall that this mean they are either 1 (with probability <span class="math inline">\(\pi\)</span>) or 0 (with probability <span class="math inline">\(1-\pi\)</span>)). The expected value for a random variable with this distribution is <span class="math inline">\(\pi\)</span>. But what does that mean? If the probability of success was 1, then all the <span class="math inline">\(y\)</span> values would be 1 and the average would be 1. Similarly for 0. If the probability, <span class="math inline">\(\pi\)</span> is somewhere in between then the mean is between 0 and 1– it’s really a measure of the <strong>proportion</strong> of successes.</p>
<p>A Bernoulli distribution (yes/no as 0 or 1) is a special case of a <strong>binomial distribution</strong>. Consider a response variable <span class="math inline">\(y\)</span> and suppose thta we have <span class="math inline">\(n\)</span> observations of <span class="math inline">\(y\)</span>, all for the <strong>same</strong> set of explanatory variable values. Each observation is, itself, Bernoulli, but the entire set of observations for that combination of <span class="math inline">\(X\)</span>-values is binomial: Different combinations of <span class="math inline">\(X\)</span>-values might have differing numbers of observations, so let’s put all the observations on similar footing by letting <span class="math inline">\(Y\)</span> represent the <strong>Proportion</strong> of observations that are 1 vs the proportion that are 0. So the <strong>count</strong> is <span class="math inline">\(B(n,\pi)\)</span> where <span class="math inline">\(\pi\)</span> represent the proportion being estimated by y. Therefore the distribution of y is defiend by:</p>
<p><span class="math display">\[
f(y|\pi,n) = {n\choose ny} \pi^{ny}(1-\pi)^{n-ny}
\]</span></p>
<p>Note that <span class="math inline">\(ny\)</span> is the <strong>count</strong>, and <span class="math inline">\(y\)</span> can only really take on the values <span class="math inline">\(\frac{0}{n},\frac{1}{n},\frac{2}{n}, \cdots, \frac{n}{n}\)</span> Surprisingly we can do some rewriting:</p>
<p><span class="math display">\[
\begin{aligned}
f(y|\pi,n) &amp;= {n\choose ny} \pi^{ny}(1-\pi)^{n-ny}\\
&amp;=\exp(\ln({n\choose ny} \pi^{ny}(1-\pi)^{n-ny}))\\
&amp;=\exp(\ln({n\choose ny})+\ln(\pi^{ny})+\ln((1-\pi)^{n-ny}))\\
&amp;=\exp(\ln({n\choose ny})+(ny)\ln(\pi)+(n-ny)\ln((1-\pi)))\\
&amp;=\exp(\ln({n\choose ny})+(ny)\ln(\pi)+(n)\ln((1-\pi)-(ny)\ln((1-\pi)))\\
&amp;=\exp(\ln({n\choose ny})+(ny)(\ln(\pi)-\ln((1-\pi))+(n)\ln((1-\pi)))\\
&amp;=\exp(\ln({n\choose ny})+(ny)(\ln(\frac{\pi}{1-\pi})+n\ln((1-\pi)))\\
&amp;=\exp\biggl((ny)\ln(\frac{\pi}{1-\pi})+n\ln(1-\pi)+\ln\bigl({n\choose ny}\bigr)\biggr)\\
&amp;=\exp\biggl(\frac{y\ln(\frac{\pi}{1-\pi})+\ln(1-\pi)}{1/n}+\ln\bigl({n\choose ny}\bigr)\biggr)\\
\theta &amp;= \ln\biggl(\frac{\pi}{1-\pi}\biggr)\\
e^\theta&amp;=\frac{\pi}{1-\pi}\\
e^\theta + 1 &amp;= \frac{1}{1-\pi}\\
\ln\bigl(e^\theta + 1 \bigr)&amp;= -\ln(1-\pi)\\
a(n) &amp;= 1/n\\
b(\theta) &amp;=\ln(e^\theta + 1)\\
c(y,n) &amp;= \frac{1}{n} \ln{n \choose ny}\\
f(y|\theta,n) &amp;= \exp\biggl(\frac{\theta y - b(\theta)}{a(n)}+c(y,n)\bigg)
\end{aligned}
\]</span></p>
<p>The key thing is that we have taken a <strong>binomial distribution</strong> and figured out functions that show it is in the <strong>exponential family</strong>. We also know that the <span class="math inline">\(mean\)</span> of the distribution occurs at</p>
<p><span class="math display">\[
\begin{aligned}
b&#39;(\theta) &amp;= \frac{e^{\theta}}{e^{\theta}+1}\\
&amp;=\frac{\frac{\pi}{1-\pi}}{\frac{\pi}{1-\pi}+1}\\
&amp;=\frac{\frac{\pi}{1-\pi}}{\frac{1}{1-\pi}}\\
&amp;=\frac{1-\pi}{1}\frac{\pi}{1-\pi}\\
&amp;=\pi
\end{aligned}
\]</span></p>
<p>The expected value for <span class="math inline">\(y\)</span> is, therefore <span class="math inline">\(\pi\)</span> (as one would expect). The link function ties the expected value to the natural parameter…so in our case we need to ues <span class="math display">\[
g(x) = \ln\left(\frac{x}{1-x}\right)
\]</span> In other words… we need to use the <strong>log odds</strong></p>
<p>If I want to know what mean the explanatory variables will predict then I use <span class="math inline">\(g^{-1}(x)\)</span> aka the response function.</p>
<p>Let’s look at the curve of the log-dds function (notice that the domain is (0,1)::</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-50-1.png" width="624" /></p>
<p>A bit of algebra should convince of the presence of vertical asymptotes AT <span class="math inline">\(X=0\)</span> and <span class="math inline">\(x=1\)</span>.</p>
<p>The graph looks monotonic so there should be an inverse (found by flipping over the lines <span class="math inline">\(y=x\)</span>).</p>
<p>Let’s try to build the inverse:</p>
<p><span class="math display">\[
\begin{aligned}
g(x) &amp;= \ln\biggl(\frac{x}{1-x}\biggr)\\
e^{g(x)}&amp;= \frac{x}{1-x}\\
1+e^{g(x)}&amp;= \frac{1}{1-x}\\
\frac{1}{1+e^{g(x)}}&amp;= 1-x\\
1-\frac{1}{1+e^{g(x)}}&amp;= x
\end{aligned}
\]</span> Let’s simplify this a bit:</p>
<p><span class="math display">\[
\begin{aligned}
f(y) &amp;= 1-\frac{1}{1+e^{y}}\\
&amp;=\frac{e^y}{1+e^y}\\
&amp;=\frac{1}{1+e^{-y}}
\end{aligned}
\]</span></p>
<p>Let’s see if we did that correctly:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-51-1.png" width="624" /></p>
<p>Congratulatoins– you’ve just derived the <strong>logistic curve</strong> The <span class="math inline">\(x\)</span>-value will, in fact, be generated using a linear prediction model…</p>
<p>###Logistic regression</p>
<p>For any given observation <span class="math inline">\(i\)</span> there is a probability (based upon <span class="math inline">\(x_i\)</span>) of <span class="math inline">\(\pi_i\)</span> for getting a 1 and <span class="math inline">\(1-\pi_1\)</span> of getting a 0. All the observations with the same value of <span class="math inline">\(x\)</span> should have the <strong>same</strong> probability of getting a 0 (or a 1). If we group all the observations with the same values for <span class="math inline">\(x\)</span> we can think of the data as having <span class="math inline">\(m\)</span> bins. The distribution of <span class="math inline">\(y\)</span> in each bin will be <span class="math inline">\(\textrm{binom}(n,\pi}\)</span> where <span class="math inline">\(n\)</span> is the number of observations in the bin.</p>
<p>Recall the mean and variance of a binomial distribution is:</p>
<p><span class="math display">\[
\begin{aligned}
y &amp;\sim \textrm{Binom}(n,p)  \\
\mathbb{E}(y) &amp;= np\\
\textrm{VAR}(y) &amp;= np(1-p)
\end{aligned}
\]</span></p>
<p>Since we have multiple bins, it’s more common to add subscripts to <span class="math inline">\(y\)</span>:</p>
<p><span class="math display">\[
y_i \sim \textrm{Binom}(n_i,\pi_i)
\]</span></p>
<p>This captures the idea that there is a <strong>distribution</strong> for the response variable associated to each combination of levels of the explanatory values. What we are predicting is the <strong>mean</strong> of this distribution…. which, for the random variable <span class="math inline">\(y_i\)</span> is <span class="math inline">\(n_i\pi_i\)</span>. The problem with this is that we really don’t want each <em>bin</em> to be a count– that’s too much variability and it would be hard to make an equation that smoothly varied. Instead if you think of the original 0,1 idea (0 for <span class="math inline">\(\textrm{no}\)</span> and 1 for <span class="math inline">\(\textrm{yes}\)</span>). You’ll notice that the distribution is a <em>scaled</em> by <span class="math inline">\(\frac{1}{n_i}\)</span> for each <span class="math inline">\(y_i\)</span>. This makes the expected value <span class="math inline">\(\pi_i\)</span>… and NOW we are in business.</p>
<p>So… if our resposne variable is 0 or 1 with a probability determined in a particular way by the explanatory variables then the distribution of the number of 1’s for each distinct combination of the explanatory variables is binomial where <span class="math inline">\(n\)</span> depends upon the data and <span class="math inline">\(\pi\)</span> is actually the <strong>average</strong> value for all the <span class="math inline">\(y\)</span>’s with that same combination of explanatory levels.</p>
<p>If the expected value is transformed into the <strong>log odds</strong> (namely <span class="math inline">\(\ln\left(\frac{p}{1-p}\right)\)</span>) Then our goal is to pick parameters for the linear part of the model that predicts the log-odds that is as consistent as possible with the observations. (This approach is called <strong>maximum liklihood</strong>). Inverting the <strong>log odds</strong> transformation predicts the value of <span class="math inline">\(\pi\)</span> and takes the form of a logistic curve.</p>
<p>In other words we are finding the logistiic curve (or higher dimensional equivalent) of best fit for the data. Here, again, “best fit” means the choice of values for the liner model that are most consistent with the data.</p>
<p>The parameters that result from a logistic regression can be viewed in terms of the “log odds”.</p>
<p>LOCAL VS ABSOLUTE MAXIMUMS AND MINIMUMS DISTRIBUTIONS LIKLIHOOD FUNCTIONS MONTECARLO VERTICAL ASYMPTOTES AND HOLES LINEAR VS NONLINEAR functions (early) In any event…</p>
<p>line of best fit.</p>
<p>We can look up (see earlier in this document) the equation for finding the line of best fit ### extrema ### product rule ### gradient ### gradient descent</p>
</div>
<div id="section-function-properties" class="section level2">
<h2>function properties</h2>
<div id="section-one-to-one-and-surjective" class="section level3">
<h3>one-to-one and surjective</h3>
</div>
<div id="section-order-preserving-functions" class="section level3">
<h3>Order preserving functions</h3>
<p>Functions that <strong>respect order</strong> or <strong>reverse order</strong> are called monotonic.</p>
<p>A function is <strong>monotonically increasing</strong> if</p>
<p><span class="math display">\[
x \le y \Rightarrow f(x) \le f(y)\quad (\textrm{for all }\ x,y)
\]</span> It is <strong>monotonically decreasing</strong> if <span class="math display">\[
x \le y \Rightarrow f(x) \ge f(y)\quad (\textrm{for all }\ x,y)
\]</span> If the function is <strong>also</strong> one-to-one then we call it <strong>monotonically strictly increasing</strong> or <strong>monotonically strictly decreasing</strong>.</p>
<p>Future version should also include reading from: <a href="https://socialsciences.mcmaster.ca/jfox/Books/Applied-Regression-2E/Appendices.pdf" class="uri">https://socialsciences.mcmaster.ca/jfox/Books/Applied-Regression-2E/Appendices.pdf</a></p>
</div>
<div id="section-means" class="section level3">
<h3>Means</h3>
<p>You are very familiar with the <strong>arithmetic mean</strong>– it’s often known as the <strong>average</strong>. It’s also how <span class="math inline">\(\overline{X}\)</span> is calculated. But that’s not the only measure of center. There are three means that have been in use for… well… longer than the language I’m using to write this tutorial has existed. All of them are a way to measure the <strong>central tendency</strong> of a set of values.</p>
<table>
<colgroup>
<col width="27%" />
<col width="34%" />
<col width="38%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Equation</th>
<th>Simple Interpretation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Arithmetic Mean</td>
<td><span class="math inline">\(\frac{1}{n}\sum x_i\)</span></td>
<td>If all <span class="math inline">\(n\)</span> observations had the same value what would it have to be to have the same sum?</td>
</tr>
<tr class="even">
<td>Geometric Mean</td>
<td><span class="math inline">\(\sqrt[n]{\prod x_i}\)</span></td>
<td>If all <span class="math inline">\(n\)</span> observations had the same value what would it have to be to have the same product?</td>
</tr>
<tr class="odd">
<td>Harmonic Mean</td>
<td><span class="math inline">\(\frac{n}{\sum \frac{1}{x_i}}\)</span></td>
<td>If two trips <strong>over the same distance</strong> are made, the harmonic mean is the average speed of the two trips combined.</td>
</tr>
</tbody>
</table>
<p>Surprisingly the following relationship is <strong>always</strong> satisfied (assuming all the values are positive)</p>
<p><span class="math display">\[
\textrm{Arithmetic Mean} &gt; \textrm{Geometric Mean} &gt; \textrm{Harmonic Mean}
\]</span> I frequently see geometric means used in normalization procedures involving transcription levels and thousands of genes. I see the harmonic mean less frequently, but one place is the F1 measure for rating how good of a job a binary classification system performs.</p>
<p>Now read this <a href="https://towardsdatascience.com/on-average-youre-using-the-wrong-average-geometric-harmonic-means-in-data-analysis-2a703e21ea0">nice introduction</a></p>
<p>ENTROPY GINI INDEX</p>
</div>
</div>
<div id="section-probabiity-refresher" class="section level2">
<h2>Probabiity Refresher</h2>
</div>
<div id="section-bayes-rule" class="section level2">
<h2>Bayes Rule</h2>
<p>Bayes rule is a deceptively simple equation. To set the stage let’s start with a a thought experiment.</p>
<p>Imagine that you are given a die to roll and you want to figure out whether or not the die is fair.</p>
<p>With no other place to start it would be reasonable to begin your assessment assuming that each face was equally possible. You could then roll the die repeatedly and keep track of the average number of times each value occurred.</p>
<p>Near the beginning of you rolled 3 sixes in a row you might start thinking that the sixes are more likely… however, if this occurred after rolling the die a couple hundred times then it would be easier to chalk it up to a lucky roll (especially since the probability of getting 3 sixes in a row on a fair die is about 1 out of 216).</p>
<p>Now let’s define some terminology.</p>
<p>The sample space is the set of possible die rolls. It is <span class="math inline">\(\Omega=\left\{1, 2, 3, 4, 5, 6\right\}\)</span>. Let’s use the letter <span class="math inline">\(D\)</span> to represent the <strong>random variable</strong> that represents the possible results from rolling the die. In this particular situation the sample space is naturally <strong>partitioned</strong> into six <strong>events</strong>:</p>
<p><span class="math display">\[
\begin{aligned}
A_1 &amp;= \left\{1\right\}\\
A_2 &amp;= \left\{2\right\}\\
A_3 &amp;= \left\{3\right\}\\
A_4 &amp;= \left\{4\right\}\\
A_5 &amp;= \left\{5\right\}\\
A_6 &amp;= \left\{6\right\}\\
\end{aligned}
\]</span></p>
<p>The more compact way to represent the situation would be:</p>
<p><span class="math display">\[
A_i = \left\{i\right\}\quad \textrm{for }i \in \Omega
\]</span> It would also be pretty natural to produce a short hand for our probabilities too:</p>
<p><span class="math display">\[
p_i = \textrm{P}(D=i)
\]</span> (Ask me if that last equation doesn’t make immediate sense to you)</p>
<p>Notice that the six events we have described have two important properties:</p>
<ol style="list-style-type: decimal">
<li>Together they <em>cover</em> the entire sample space</li>
<li>The events have no outcomes in common</li>
</ol>
<p>This is the formal definition of a <strong>partition</strong>.</p>
<p>Our fundamental strategy for figuring out if the die is fair or not is to calculate the values of <span class="math inline">\(p_i\)</span>. At each step we have a **best guess* to the true values of <span class="math inline">\(p_i\)</span>. We proceed as follows:</p>
<ol style="list-style-type: decimal">
<li>Roll the die</li>
<li>Update our best guess for every <span class="math inline">\(p_i\)</span></li>
<li>Repeat… lots</li>
</ol>
<p>In Bayesian statistics we call the best estimate <em>just before</em> rolling again the <strong>prior distribution</strong>. After we get more data our updated estimate is the <strong>posterior distribution</strong></p>
<p>So let’s take a break and review <strong>Bayes rule</strong>.</p>
<p>We start with a sample space <span class="math inline">\(\Omega\)</span> that can be exhaustively covered by <span class="math inline">\(n\)</span> mutually exclusive events <span class="math inline">\(\left\{A_i\right\}\)</span>. That’s like the 6 possible results of rolling the die.</p>
<p>We then consider some event <span class="math inline">\(C\)</span>– usually one that</p>
<p><span class="math display">\[
\begin{aligned}
\Omega &amp;= A_1 \cup A_2 \cup \cdots \cup A_n\\
A_i \cap A_j &amp;= \emptyset\qquad(\textrm{for } i \ne j)\\
\end{aligned}
\]</span> ## Linear Combinations</p>
<p>For any vector space, a <strong>linear combination</strong> is a collection of components added together. Each component is comprised of a vector and a scalar. For example the following expression is a <strong>linear combination</strong> of the vectors <span class="math inline">\((3,4,-1)\)</span> and <span class="math inline">\((1,-2,0)\)</span></p>
<p><span class="math display">\[
2(3,4,-1) + (-3)(1,-2,0)
\]</span> Numbers can be considered as 1 dimensional vectors… so it makes sense to talk about linear combinations of numbers too. A surprising amount of mathematics arises from this idea and its generalizations. One minor generalization ignores the vector space requirement. For example, consider linear combinations of integers. For example we might consider linear combinations of 6 and 9. That would be any expression of the form <span class="math inline">\(a6 + b9\)</span> where <span class="math inline">\(a,b \in \mathbb{Z}\)</span>. There can be a bit of confusion in the terminology because one would call the expression <span class="math inline">\((-1)*6+1*9\)</span> a linear combination of 6 and 9, but one would also call 3 a linear combination of 6 and 9 because <span class="math inline">\((-1)*6+1*9=3\)</span>. Both are correct. The first contains a bit more information because, for example, <span class="math inline">\(1*6+(0)*9=6\)</span> is a linear combination of 6 and 9, but so is <span class="math inline">\((-2)*6+2*9=6\)</span>. To keep things straight we will always refer to the multipliers as scalars in this situation… even though we might not be referring to a proper vector space.</p>
<p>In the example <span class="math inline">\((-1)*6 + 1*9=3\)</span>, 3 is a linear combination of 6 and 9, using the the scalars were -1 and 1.</p>
<p>Also notice that a <strong>weighted average</strong> of values is a linear combination as well, but with the special property that the scalars all add to 1. It is an interesting (and useful) fact that the weighted average of a set of numbers is somewhere between the mininum number and the maximum number. ADD EXERCISE HERE!</p>
<p>In the case of vectors where the scalars are more extensive, such as <span class="math inline">\(\mathbb{R}\)</span>, there are actually situations where there is only ONE linear combination (in the first sense) that will generate the same value (the linear combination in the second sense). This is completely determined by the nature of the vectors involved. A set of vectors with this property is called <strong>linearly independent</strong>.</p>
<p>It’s not as confusing as you might think. For example the set <span class="math inline">\((1,0,0),(0,1,0)\)</span> is linearly independent.</p>
<p>The set of all linear combinations (in the seconds sense of the word) is called the <strong>span</strong> of a set of vectors.</p>
<p>If a linearly indpendent set of vectors spans a set, the vectors are also known as a <strong>basis</strong>. Every element in the set can be uniquely written as the lienar combination of the basis.</p>
</div>
<div id="section-graphs" class="section level2">
<h2>Graphs</h2>
<p>In more advanced mathematics a <strong>graph</strong> is a collection of <strong>vertices</strong> (or <strong>nodes</strong>) and <strong>edges</strong> that connect them.</p>
<p>Here is a simple example:</p>
<p>TIKZexample</p>
<p>In a <strong>directed graph</strong> the edges have a natural direction. In an <strong>undirected graph</strong> there is no sense of direction.</p>
<p>Graphs can be represented visually as circles (the nodes) connected with either arrows (for a directed graph) or line segments (For an undirected graph).</p>
<p>In most applications <strong>parallel edges</strong> between the same two nodes are not allowed. In a directed graph two edges are not parallel unless they also share the same direction, so</p>
<p><span class="math inline">\((\textrm{A})\rightarrow(\textrm{B})\)</span> and <span class="math inline">\((\textrm{A})\leftarrow(\textrm{B})\)</span></p>
<p>is legal.</p>
<p>A <strong>loop</strong> is an edge joining a vertex to itself. These are also usually not allowed.</p>
<p>The original idea of a graph arose from the HERTZOG BRIDGE problem, and the edge was used to represent a path between the two sections of the park. The paths were not one-way so this was an undirected graph.</p>
<p>As the idea developed it became useful to associate <strong>weights</strong> to edges or to vertices (usually to edges). The weight might represent the <strong>cost</strong> or <strong>distance</strong> of a trip (or some more abstract variant of the same.)</p>
<p>A <strong>subgraph</strong> of a graph is a collection of that graph’s vertices and edges– usually with at least a few left out.</p>
<p>A <strong>complete graph</strong> (undirected) of order <span class="math inline">\(n\)</span> has <span class="math inline">\(n\)</span> vertices, all of which are directly connected to each other.</p>
<p>When a complete graph of order <span class="math inline">\(k\)</span> is a subgraph of a larger graph, it is known as a <strong>clique</strong>. For <span class="math inline">\(k=2\)</span> all the 2-cliques correspond to the edges of the graph (the edge and the two vertices that it connects.)</p>
<p>Given any two vertices we can consider a sequence of edges (if any) between those two vertices. This is known as a <strong>path</strong>. If there is a path leading from one vertex back to itself then that path is known as a <strong>cycle</strong>.</p>
<p>Graphs are frequently used to encode information about <strong>relationships</strong> between objects and one particularly interesting form of relationship that they encode is a <strong>dependence structurre</strong> amongst variables.</p>
<p>Under this idea each variable has an associated node, and variables that are <strong>not</strong> indpendent have an edge connecting them.</p>
<p>With vertices it is more common to associate a <em>color</em> to them. This gives rise to a number of interesting mathematical properties of a graph. For example, what is the fewest number of colors that can be used to color a graph such that no two vertices with the same color are connected.</p>
<p>One special case of this situation is a <strong>bipartite graph</strong> which can be colored with two colors alone.</p>
<p>Directed graphs with weighted edges can be encoded as a square matrix where the entries in the matrix correspond to the weight of the edges. We assign to each vertex an index and let the rows of the matrix recommend the <strong>source</strong> of an edge and the col represent the <strong>target</strong>. Under this convention, the row (say row <span class="math inline">\(i\)</span>) and the column (say col <span class="math inline">\(j\)</span>) correspond to the edge (if any) between node <span class="math inline">\(i\)</span> and node <span class="math inline">\(j\)</span>. A value of 0 denotes no connection between the two nodes.</p>
<p>There are some really cool consequences to this style of encoding. First– we can, clearly, read the weight of the edges between two nodes directly off the matrix. This is known as the <strong>adjacency matrix</strong> of the graph. (For unweighted graphs we can use 0 and 1 to denote edge/not-edge)</p>
<p>Let’s suppose our matrix is called <span class="math inline">\(A\)</span>, then the entries of the matrix <span class="math inline">\(A^2\)</span> (formed via matrix multiplication of the matrix <span class="math inline">\(A\)</span> with itself). Show the sum of the cost of the sum of <strong>all</strong> paths of length two between the corresponding matrices.</p>
<p>This is interesting because (when weights are non-negative) it allows us to easily detect when two vertices are <strong>2-reachable</strong> (if the number is 0 there is no path of length 2 between the two )</p>
<p>The sort of neat thing about all of this is that <strong>any</strong> square matrix can be considered to be an adjacency matrix– and the properties of the graph it describes tells us something about the linear transformation encoded by the matrix.</p>
<p>EXAMPLE</p>
<p>SHOW EXAMPLE</p>
</div>
<div id="section-more-stuff-with-the-derivative" class="section level2">
<h2>More stuff with the derivative</h2>
<p>One of the more useful thing about calculating derivatives arises for functions that are built out of simpler functions using operations like</p>
<ul>
<li>addition/subtraction</li>
<li>multiplication/division</li>
<li>composition</li>
</ul>
<p>For example. If the following is true:</p>
<p><span class="math display">\[
f(x) = g(x) + h(x)
\]</span> Then the function <span class="math inline">\(f(x)\)</span> is built out of <span class="math inline">\(g(x)\)</span> and <span class="math inline">\(h(x)\)</span> combined with addition. It turns out that the <strong>derivative</strong> of <span class="math inline">\(f(x)\)</span> is built out of the derivatives of <span class="math inline">\(g(x)\)</span> and <span class="math inline">\(h(x)\)</span> in the same fashion</p>
<p><span class="math display">\[
f&#39;(x) = g&#39;(x) + h&#39;(x)
\]</span></p>
<p>If we think of <span class="math inline">\(f(x)\)</span> as specificying the position for some object at location <span class="math inline">\(x\)</span> then <span class="math inline">\(f&#39;(x)\)</span> is the speed of that object at location <span class="math inline">\(x\)</span>.</p>
<p>So the <strong>speed of <span class="math inline">\(f(x)\)</span></strong> is the speed of <span class="math inline">\(g(x)\)</span> plus the speed of <span class="math inline">\(h(x)\)</span>. In other words <strong>derivatives are additive</strong>.</p>
<p>It’s not quite as simple as the for products… but we can get a bit of a sense for what’s going on with a picture:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-52-1.png" width="624" /></p>
<p>THink about the interior, rectange with white background and think of that as being <span class="math inline">\(f(x)g(x)\)</span>. As <span class="math inline">\(x\)</span> changes, <span class="math inline">\(f(x)\)</span> (the width) changes and so does <span class="math inline">\(g(x)\)</span> the height.</p>
<p>You can think of the derivative as the instantaneous rate of change. But we <strong>approximate</strong> this by making small changes in <span class="math inline">\(x\)</span> (which we call <span class="math inline">\(\Delta x\)</span>) look at the result and take the ratio of the change in <span class="math inline">\(y\)</span> and the change in <span class="math inline">\(x\)</span>: <span class="math inline">\(\frac{f(x+\Delta x)}{\Delta x}\)</span>. This is the <strong>approximate change</strong>. But if consider the ratio as <span class="math inline">\(\Delta x\)</span> goes to 0 (gets really small) we get increasingly accurate approximations.</p>
<p>So consider this picture:</p>
<p><img src="Math-Background_files/figure-html/unnamed-chunk-53-1.png" width="624" /></p>
<p>The width of the entire section is <span class="math inline">\(f(x+\Delta x)\)</span>. The first section is <span class="math inline">\(f(x)\)</span>. So the width of the darkest region is an approximation to <span class="math inline">\(f(x+\Delta x)-f(x)\approx f&#39;(x) \Delta x\)</span> #4 6 18 19 23</p>
<p>We would measure the value of <span class="math inline">\(f(x)g(x)\)</span> by the number of unit squares that it encompasses and so to measure the rate of change we need to measure how the squares change. If <span class="math inline">\(g(x)\)</span> were constant than we would go from <span class="math inline">\(f(x)\)</span> to <span class="math inline">\(f(x) + \Delta x\)</span>. And the change would then be the rightmost shaded rectangle which is approximately <span class="math inline">\(g(x)f&#39;(x) \Delta x\)</span>. If only <span class="math inline">\(g(x)\)</span> were to change then <span class="math inline">\(g&#39;(x)f(x)\Delta x\)</span> would be the upper rectangle area. The littel tiny square in the right corner is then approximately <span class="math inline">\(f&#39;(x)g&#39;(x) (\Delta x)^2\)</span> To figure out the <strong>overall</strong> (approximate) rate of change we then divide by <span class="math inline">\(\Delta x\)</span>.</p>
<p>So, in the limit:</p>
<p><span class="math display">\[
\left[f(x)g(x)\right]&#39;=f&#39;(x)g(x) + f(x)g&#39;(x)
\]</span> Now the most interesting one is what happens when we compose <span class="math inline">\(f(g(x))-f(g(x+\Delta x))\)</span>. Try to think about what that would mean.</p>
<p>As <span class="math inline">\(x\)</span> is changing this induces a change in <span class="math inline">\(g(x)\)</span> which, in turn, induces a change in <span class="math inline">\(f(x)\)</span>. Let’s start by considering some of the easiest functions possible– linear ones:</p>
<p><span class="math display">\[
\begin{aligned}
f(x) &amp;= ax + b\\
g(x) &amp;= cx + d\\
f(g(x))&amp;= a(g(x))+b\\
&amp;= a(cx+d) + b\\
&amp;= acx + ad + b
\end{aligned}
\]</span> The rate of change here is <span class="math inline">\(ac\)</span>. Notice this is the rate of change of <span class="math inline">\(f(x)\)</span> times the rate of change of <span class="math inline">\(g(x)\)</span>… Even though for these simle functions the rate of change is the same for every value of <span class="math inline">\(x\)</span>, if we are very clever we might notice that we care about the rate of change of <span class="math inline">\(f\)</span> and <span class="math inline">\(g(x)\)</span>. So, it’s more accurate to write: <span class="math inline">\(f&#39;(g(x))g&#39;(x)\)</span>.</p>
<p>The <strong>magic</strong> of derivatives is that they make everything look linear (at least locally). So the rule is the same:</p>
<p><span class="math display">\[
[f(g(x))]&#39; = f&#39;(g(x))g&#39;(x)
\]</span></p>
<p>The speed of the composition is the speed of g at <span class="math inline">\(x\)</span> <strong>times</strong> the speed of <span class="math inline">\(f\)</span> at <span class="math inline">\(g(x)\)</span>.</p>
<p>We can see this to some extent</p>
<p><div class="form-group shiny-input-container">
<label class="control-label" for="x">Value of x</label>
<input class="js-range-slider" id="x" data-min="0" data-max="1.2" data-from="0" data-step="0.05" data-grid="true" data-grid-num="8" data-grid-snap="false" data-prettify-separator="," data-prettify-enabled="true" data-keyboard="true" data-data-type="number"/>
<div class="slider-animate-container">
<a href="#" class="slider-animate-button" data-target-id="x" data-interval="200" data-loop="TRUE">
<span class="play">
<i class="glyphicon glyphicon-play"></i>
</span>
<span class="pause">
<i class="glyphicon glyphicon-pause"></i>
</span>
</a>
</div>
</div><div id="animPlot" class="shiny-plot-output" style="width: 600px ; height: 600px"></div></p>
<p>There are a lot of moving parts (ha!) in this diagram, so be sure to trace them all. The left panel shows <span class="math inline">\(x\)</span>, <span class="math inline">\(f(x)\)</span> and the relationship between the speed of <span class="math inline">\(x\)</span> and the speed of <span class="math inline">\(f(x)\)</span> (as recorded by <span class="math inline">\(f&#39;(x)\)</span> and graphically represented by the <strong>slope</strong> of the dotted line). Watch how the horizontally moving gray dot and the vertically moving gray dot are connected by the graph of <span class="math inline">\(f(x)\)</span>. The dot on the horizontal line is the value of <span class="math inline">\(x\)</span>, it should be changing at a constant rate. The dot on the vertical line is value of <span class="math inline">\(f(x)\)</span>, it’s rate of change will depend upon the graph of <span class="math inline">\(f(x)\)</span>. Notice that when the slope of the <strong>tangent line</strong> is negative, the dot on the vertical line is going down. When the slope of the tangent line is positive, the dot on the vertical line is going up.</p>
<p>Further notice that the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> limits on the graph are not identical… so the exact value of the slope is a bit hard to eyeball– you really do need to think about the equation <span class="math display">\[\textrm{slope}=\frac{\textrm{rise}}{\textrm{run}}\]</span> in order to calculate the exact value. Regardless, positive slopes and negative slopes are unaffectd by this x-scale vs y-scale issue.</p>
<p>When we <strong>compose</strong> two functions, we plug the output of one function into the input of the other. Notice that the value of the point on the second horizontal line is precisely the same as the value of the point on the <strong>vertical line</strong> in the first panel. Therefore the speed at which the first vertical point is moving is the same as the speed of the second horizontal point (with scale issues somewhat obscuring this fact)</p>
<p>The vertical line on the right panel is the composition <span class="math inline">\(g(f(x))\)</span>. It’s exact instantaneous velocity is indicated on the right panel. Try pausing the animation and looking at a few values of <span class="math inline">\(x\)</span>. Make sure the relationship makes sense… then just let the animation loop and soak it in for a bit.</p>
<p>Finally, notice that the velocity of the composition is determined by the multiplication of the slopes of the two dotted lines. These slopes are the velocity of <span class="math inline">\(f(x)\)</span> at <span class="math inline">\(x\)</span> and the velocity of <span class="math inline">\(g(x)\)</span> <strong>at</strong> <span class="math inline">\(f(x)\)</span>. Read that last sentence a few times… I used <span class="math inline">\(g(x)\)</span> on purpose (although the distinction between <span class="math inline">\(g(x)\)</span> and <span class="math inline">\(f(x)\)</span> in that final clause requires some careful thought.)</p>
<p>Let’s just say it one more way… <em>IF</em>,at a particular input, <span class="math inline">\(g(x)\)</span> produces a velocity that is <span class="math inline">\(3\)</span> times that of the velocity of the input. Then if the velocity at which the input is changing is 2, the total velocity would be 3*2=6. Now… if we patch the output of <span class="math inline">\(f(x)\)</span> into the input of <span class="math inline">\(g(x)\)</span></p>

<script type="application/shiny-prerendered" data-context="server-start">
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
#source(file="fitControls.R",local=TRUE)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-convert-to-character-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-convert-to-character-code-editor`)), session)
output$`tutorial-exercise-convert-to-character-output` <- renderUI({
  `tutorial-exercise-convert-to-character-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-matrix-1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-matrix-1-code-editor`)), session)
output$`tutorial-exercise-matrix-1-output` <- renderUI({
  `tutorial-exercise-matrix-1-result`()
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
enparen=function(txt){paste0("(",txt,")")}
output$dPlot <- renderPlot({
  f=function(x){x^2 - 3}
  f.prime=function(x){2*x}
  inc=input$increment
  x1=input$deriv.x
  y1=f(x1)
  x2=x1+inc
  y2=f(x2)
  msg=""
  if(input$numerics){
    num=paste0(round(y2,3),"-",round(y1,3))
    denom=paste0(round(x2,3),"-",round(x1,3))
    msg=paste0(enparen(num),"/",enparen(denom))
    msg=paste0(msg,"=",round((y2-y1)/(x2-x1),3))
    msg=paste0("Average change: ",msg)
  }
  
  curve(f(x),x1-inc,x1+2*inc,xlab="x",ylab="y",sub=msg)
  points(x1,y1,cex=2,pch=20)
  if(input$avgChange){
    points(x2,y2,pch=20,col="skyblue",cex=2)
    m=(y2-y1)/(x2-x1)
    b=y2-m*x2
    abline(b,m,lty=2,col="lightgray")
  }
  if(input$avgChange){
    points(x2,y2,pch=20,col="skyblue",cex=2)
    m=(y2-y1)/(x2-x1)
    b=y2-m*x2
    abline(b,m,lty=2,col="lightgray")
  }
  if(input$instantChange){
    m=f.prime(x1)
    b=y1-m*x1
    abline(b,m,lty=2,col="pink")
  }
  
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
output$iterPlot=renderPlot({
  f=function(x){x^2-3}
  f.prime=function(x){2*x}
  x.iter=iter(-2,f,f.prime)
  curve(f(x),-2,3,ylim=c(-3.5,6))
  points(x.iter,f(x.iter))
  x.guess=x.iter[input$iterGuess]
  points(x.guess,f(x.guess),pch=19,col="red") 
  if(input$iterShowLine){
    text(-1.7,4,paste0("Guess: ",round(x.guess,3)))
    text(-1.7,3.5,paste0("Value: ",round(f(x.guess),3)))
    text(-1.7,3,paste0("Slope: ",round(f.prime(x.guess),3)))
    m=f.prime(x.guess)
    b=f(x.guess)-m*x.guess
    abline(b,m,lty=2,col="red")
    points(x.guess,-3.5,pch="V",cex=2)
  }
  
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
output$mvnPlot=renderPlot({
  library(mvtnorm)
  mv=c(0,0)
  covar=input$covar
  sigma=matrix(c(input$x1.var,covar,covar,input$x2.var),nrow=2)
  rx=seq(-3,3,length.out=21)
  ry=rx
  results=matrix(0,nrow=length(rx),ncol=length(ry))
  x=rx[1]
  for(i in 1:length(rx)){
    for(j in 1:length(ry)){
      results[i,j]=dmvnorm(c(rx[i],ry[j]),mv,sigma)#,mv,sigma)
    }
  }
  persp(z=results,theta=input$theta,phi=input$phi)
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
output$planePlot=renderPlot({
  plane=function(x,y,dx,dy,x0=0,y0=0,z0=0){ #Assume plane passes through (0,0)
    delta.x=x-x0
    delta.y=y-y0
    z0+delta.x*dx + delta.y*dy
  }
  n=40
  x=seq(-1,1,length.out=n)
  y=seq(-1,1,length.out=n)
  dx=input$partialX
  dy=input$partialY
  results=matrix(0,nrow=length(x),ncol=length(y))
  for(i in 1:n){
    for(j in 1:n){
      results[i,j]=plane(x[i],y[j],dx,dy)
    }
  }
  persp(z=results,zlim=c(-3,3))
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">

output$lineFit=renderPlot({
  set.seed(1) # Ensure we get the same values:
  x=runif(100)
  y=2+3*x +rnorm(100,0,0.3)
  b=input$model.intercept
  m=input$model.slope
  plot(x,y,pch=20,cex=2)
  abline(lty=2,col="red",lwd=3,b,m)
})
output$paramExplore=renderPlot({
    set.seed(1) # Ensure we get the same values:
  x=runif(100)
  y=2+3*x +rnorm(100,0,0.3)

  .f=function(b,m){sum((y-b-m*x)^2)}
  .g=Vectorize(.f)
  #b.min=input$model.min.b
  #b.max=input$model.max.b
  #m.min=input$model.min.m
  #m.max=input$model.max.m
  b.min=0.4
  b.max=3.6
  m.min=-0.4
  m.max=5.1
  b=seq(b.min,b.max,length.out=30)
  m=seq(m.min,m.max,length.out=30)
  z=outer(b,m,.g)*-1
  ss=.g(input$model.intercept,input$model.slope)*-1
  if(input$model.exponentiate){
      z=exp(z)
      ss=exp(ss)
  }
  gx=input$model.intercept
  gy=input$model.slope
  pmat=persp(b,m,z,theta=input$model.theta,phi=input$model.phi,r=1)
  points(trans3d(gx,gy,ss,pmat),cex=2,col="red",pch=20)
  })
output$paramContour=renderPlot({
  set.seed(1) # Ensure we get the same values:
  x=runif(100)
  y=2+3*x +rnorm(100,0,0.3)

  .f=function(b,m){sum((y-b-m*x)^2)}
  .g=Vectorize(.f)
  #b.min=input$model.min.b
  #b.max=input$model.max.b
  #m.min=input$model.min.m
  #m.max=input$model.max.m
  b.min=0.4
  b.max=3.6
  m.min=-0.4
  m.max=5.1
  b=seq(b.min,b.max,length.out=100)
  m=seq(m.min,m.max,length.out=100)
  z=outer(b,m,.g)*-1
  ss=.g(input$model.intercept,input$model.slope)*-1
  if(input$model.exponentiate){
      z=exp(z)
      ss=exp(ss)}
  gx=input$model.intercept
  gy=input$model.slope
  contour(b,m,z)
  points(gx,gy,cex=2,col="red",pch=20)
  })
</script>
 
<script type="application/shiny-prerendered" data-context="server">

output$lineFit2=renderPlot({
  set.seed(1) # Ensure we get the same values:
  x=runif(100)
  y=2+3*x +rnorm(100,0,0.3)
  b=input$model.intercept2
  m=input$model.slope2
  plot(x,y,pch=20,cex=2)
  abline(lty=2,col="red",lwd=3,b,m)
})
output$paramExplore2=renderPlot({
  set.seed(1) # Ensure we get the same values:
  x=runif(100)
  y=2+3*x +rnorm(100,0,0.3)

  .f=function(b,m){sum(abs(y-b-m*x))}
  .g=Vectorize(.f)
  #b.min=input$model.min.b
  #b.max=input$model.max.b
  #m.min=input$model.min.m
  #m.max=input$model.max.m
  b.min=0.4
  b.max=3.6
  m.min=-0.4
  m.max=5.1
  b=seq(b.min,b.max,length.out=30)
  m=seq(m.min,m.max,length.out=30)
  z=outer(b,m,.g)*-1
  sa=.g(input$model.intercept2,input$model.slope2)*-1
  if(input$model.exponentiate2){
      z=exp(z)
      sa=exp(sa)}
  #ss=(ss-min(z))/(max(z)-min(z)) #Convert to [0,1]
  #gx=(input$model.intercept-b.min)/(b.max-b.min)
  #gy=(input$model.slope-m.min)/(m.max-m.min)
  gx=input$model.intercept2
  gy=input$model.slope2
  pmat=persp(b,m,z,theta=input$model.theta2,phi=input$model.phi2,r=1)
  points(trans3d(gx,gy,sa,pmat),cex=2,col="red",pch=20)
  })
output$paramContour2=renderPlot({
    set.seed(1) # Ensure we get the same values:
  x=runif(100)
  y=2+3*x +rnorm(100,0,0.3)

  .f=function(b,m){sum(abs(y-b-m*x))}
  .g=Vectorize(.f)
  #b.min=input$model.min.b
  #b.max=input$model.max.b
  #m.min=input$model.min.m
  #m.max=input$model.max.m
  b.min=0.4
  b.max=3.6
  m.min=-0.4
  m.max=5.1
  b=seq(b.min,b.max,length.out=100)
  m=seq(m.min,m.max,length.out=100)
  z=outer(b,m,.g)*-1
  sa=.g(input$model.intercept2,input$model.slope2)*-1
  if(input$model.exponentiate2){
      z=exp(z)
      sa=exp(sa)}
  gx=input$model.intercept2
  gy=input$model.slope2
  contour(b,m,z)
  points(gx,gy,cex=2,col="red",pch=20)
  })
</script>
 
<script type="application/shiny-prerendered" data-context="server">

output$lineFit3=renderPlot({
  set.seed(1) # Ensure we get the same values:
  x=runif(100)
  y=2+3*x +rgamma(100,1,0.3)
  b=input$model.intercept3
  m=input$model.slope3
  plot(x,y,pch=20,cex=2)
  abline(lty=2,col="red",lwd=3,b,m)
  abline(lm(y~x),col="blue",lty=2,lwd=3)
})
output$paramExplore3=renderPlot({
  set.seed(1) # Ensure we get the same values:
  x=runif(100)
  y=2+3*x +rgamma(100,1,0.3)

  .f=function(b,m){sum(abs(y-b-m*x))}
  .g=Vectorize(.f)
  #b.min=input$model.min.b
  #b.max=input$model.max.b
  #m.min=input$model.min.m
  #m.max=input$model.max.m
  b.min=0
  b.max=8
  m.min=0
  m.max=8
  b=seq(b.min,b.max,length.out=30)
  m=seq(m.min,m.max,length.out=30)
  z=outer(b,m,.g)*-1
  sa=.g(input$model.intercept3,input$model.slope3)*-1
  if(input$model.exponentiate3){
      z=exp(z)
      sa=exp(sa)}
  #ss=(ss-min(z))/(max(z)-min(z)) #Convert to [0,1]
  #gx=(input$model.intercept-b.min)/(b.max-b.min)
  #gy=(input$model.slope-m.min)/(m.max-m.min)
  gx=input$model.intercept3
  gy=input$model.slope3
  pmat=persp(b,m,z,theta=input$model.theta3,phi=input$model.phi3,r=1)
  points(trans3d(gx,gy,sa,pmat),cex=2,col="red",pch=20)
  })
output$paramContour3=renderPlot({
    set.seed(1) # Ensure we get the same values:
  x=runif(100)
  y=2+3*x +rgamma(100,1,0.3)


  .f=function(b,m){sum(abs(y-b-m*x))}
  .g=Vectorize(.f)
  #b.min=input$model.min.b
  #b.max=input$model.max.b
  #m.min=input$model.min.m
  #m.max=input$model.max.m
  b.min=0
  b.max=8
  m.min=0
  m.max=8
  b=seq(b.min,b.max,length.out=100)
  m=seq(m.min,m.max,length.out=100)
  z=outer(b,m,.g)*-1
  sa=.g(input$model.intercept3,input$model.slope3)*-1
  if(input$model.exponentiate3){
      z=exp(z)
      sa=exp(sa)}
  gx=input$model.intercept3
  gy=input$model.slope3
  contour(b,m,z)
  points(gx,gy,cex=2,col="red",pch=20)
  })
</script>
 
<script type="application/shiny-prerendered" data-context="server">
output$paramGLMExplore=renderPlot({

      f.def=paste0("function(phi){",input$modelglm.a,"}")
      #cat(f.def,"\n")
      f.a=eval(parse(text=f.def))
      f.def=paste0("function(theta){",input$modelglm.b,"}")
      #cat(f.def,"\n")
      f.b=eval(parse(text=f.def))
      f.def=paste0("function(y,phi){",input$modelglm.c,"}")
      #cat(f.def,"\n")
      f.c=eval(parse(text=f.def))
      theta=input$modelglm.theta
      phi=input$modelglm.phi
      theta=input$modelglm.theta
      phi=input$modelglm.phi
      
      distrib=function(y){
        #cat("theta",theta,"\n")
        #cat("phi",phi,"\n")
        #cat("y",y,"\n")
        #cat("y*theta",theta*y,"\n")
        #cat("f.b(theta)","\n",f.b(theta))
        #cat("f.a(phi)","\n",f.a(phi))
        #cat("f.c(y,phi)","\n",f.c(y,phi))
        
        exp((y*theta-f.b(theta))/f.a(phi)+f.c(y,phi))
      }
      curve(distrib(x),-3,3)
})
</script>
 
<script type="application/shiny-prerendered" data-context="server">
output$animPlot=renderPlot({
  oldPar=par(mfrow=c(1,2))
  f=function(x){
    #5*(x)*(x-0.5)*(x-1)
    5*(x^3-1.5*x^2+0.5*x)
  }
  f.prime=function(x){
    5*(3*x^2-3*x+0.5)
  }
  g=function(x){
    #2*(x-0.25)*(x+0.25)
    2*(x^2-0.0625)
  }
  g.prime=function(X){
    4*X
  }
  pt.slope=function(p.x,p.y,m){
    slope=m
    intercept=-p.x*m+p.y
    abline(intercept,slope,lty=2,col="darkgray")
    text(p.x,p.y,round(slope,1),pos=3,offset=-1)
  }
  x=input$x
  curve(f(x),-0.25,1.25,ylab="f(x)")
  abline(h=-1,col="lightgray")
  abline(v=-0.25,col="lightgray")
  pt.slope(x,f(x),f.prime(x))
  points(x,f(x),cex=2,pch=20)
  points(x,-1,cex=2,pch=20,col="lightgray")
  points(-0.25,f(x),cex=2,pch=20,col="lightgray")
  curve(g(x),-1,1,ylab="g(f(x))",ylim=c(-0.5,2))
  abline(h=-0.5,col="lightgray")
  abline(v=-1,col="lightgray")
  pt.slope(f(x),g(f(x)),g.prime(f(x)))
  points(f(x),g(f(x)),cex=2,pch=20)
  points(f(x),-0.5,cex=2,pch=20,col="lightgray")
  points(-1,f(x),cex=2,pch=20,col="lightgray")
  text(-0.75,-0.4,"-f(x)-")
  text(0,2,paste("speed of composition: ",round(f.prime(x)*g.prime(f(x)),1)))
  par(oldPar)
})
</script>
 <!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.15"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.15"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.15"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.15"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-autocompletion"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-autocompletion.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-diagnostics"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-diagnostics.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["1.11.3"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/jquery"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.15"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["5.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.css","css/v4-shims.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["1.15"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["4.4.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["localforage"]},{"type":"character","attributes":{},"value":["1.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/localforage"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["localforage.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-autocompletion"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-autocompletion.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-diagnostics"]},{"type":"character","attributes":{},"value":["0.9.2.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-diagnostics.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.2.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["1.5.15"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.9.2.1"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ionrangeslider"]},{"type":"character","attributes":{},"value":["2.1.6"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/ionrangeslider"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/ion.rangeSlider.min.js"]},{"type":"character","attributes":{},"value":["css/ion.rangeSlider.css","css/ion.rangeSlider.skinShiny.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["strftime"]},{"type":"character","attributes":{},"value":["0.9.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["href"]}},"value":[{"type":"character","attributes":{},"value":["shared/strftime"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["strftime-min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"logical","attributes":{},"value":[true]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]}},"value":[{"type":"character","attributes":{},"value":["backports","base","compiler","datasets","digest","evaluate","graphics","grDevices","grid","htmltools","htmlwidgets","httpuv","jsonlite","knitr","later","lattice","learnr","magrittr","markdown","Matrix","methods","mime","promises","R6","Rcpp","reticulate","rmarkdown","rprojroot","shiny","stats","stringi","stringr","tools","utils","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["1.1.4","3.5.3","3.5.3","3.5.3","0.6.21","0.14","3.5.3","3.5.3","3.5.3","0.3.6","1.3","1.5.2","1.6","1.25","0.8.0","0.20-38","0.9.2.1","1.5","1.1","1.2-17","3.5.3","0.7","1.0.1","2.4.0","1.0.2","1.13","1.15","1.3-2","1.3.2","3.5.3","1.4.3","1.4.0","3.5.3","3.5.3","2.1.2","0.9","1.8-4","2.2.0"]}]}]}
</script>
<!--/html_preserve-->
</div>
<div class="footnotes">
<hr />
<ol>
<li id="section-fn1"><p>this expression will generate an error in R<a href="#section-section-fnref1" class="footnote-back">↩</a></p></li>
</ol>
</div>

</div> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h2 class="title toc-ignore" style="display:none;">Tutorial</h2>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</div> <!-- bandContent page -->
</div> <!-- pageContent band -->




<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>

</html>
